# 더 멀리 나가기

## A.1 값 vs 참조

값을 할당하고 전달할 때, 원시 타입과 객체가 어떻게 다를까?

값을 할당하거나 전달할 때 직접 **값 그 자체** 를 할당, 전달할지 아니면 **값의 참조** 를 할당, 전달할지 개발자가 선택할 수 있도록 하는 프로그래밍 언어가 많다. 그런데 JS에서는 이 과정이 오로지 값의 타입으로만 결정된다. JS에서는 원시 타입 값을 할당, 전달할 때 값이 복사되어 할당, 전달된다.

```js
var nyName = "서하";

var yourName = myName;
```

예시에서 변수 `yourName`에는 변수 `myName`에 할당된 값인 `"서하"`를 복사한 독립된 문자열이 저장된다. 값이 원시 타입이므로 값 할당, 전달 시 이와 같이 값이 복사된다. `yourName`과 `myName`의 값이 독립적이라는 것은 아래 예시를 통해 증명할 수 있다.

```js
var myName = "서하";

var yourName = myName;

myName = "기원";

console.log(myName);
// 기원

console.log(yourName);
// 서하
```

두 변수에는 독립적으로 복사된 값이 저장되므로 변수 `myName`에 새로운 값인 `"기원"`을 할당 하더라도 `yourName`이 영향을 받지 않는다.

이와 대조적으로 참조는 두 개 혹은 그 이상의 변수가 하나의 값(공유 값)을 가리키므로 공유하는 값을 수정하면 이 값을 참조하는 모든 변수가 영향을 받는다. JS에서는 객체값(객체, 배열, 함수 등)만 참조로 처리된다.

예시를 살펴보자

```js
var myAdress = {
  street: "종로구 청와대로1",
  city: "서울특별시",
  country: "대한민국",
};

var yourAddress = myAddress;

// 새로운 집으로 이사한다고 가정해보자
myAddress.street = "서울특별시 영등포구 의사당대로 1";

console.log(yourAddress.street);
// 서울특별시 영등포구 의사당대로 1
```

변수 `myAddress`에 객체를 할당했으므로 `myAdress`에는 객체가 아닌 객체의 참조가 저장, 할당된다. 그렇기 떄문에 `yourAddress`에도 `myAdress`에 할당한 객체가 아닌 `myAdress`에 할당된 참조의 복사가 할당된다. 따라서 `yourAddress.street`에 접근하면 `MyAddress.street`를 통해 갱신한 값이 출력된다. `myAddress`와 `yourAddress`에는 공유된 값인 객체에 대한 참조가 각각 복사되어 할당되므로 두 변수 중 하나만 수정해도 둘 다 갱신되는 효과가 있다.

다시 한번 정리하면 JS에서는 값을 복사할지 참조를 복사할지가 값의 타입에 따라 결정된다. 원시값은 그 값 자체를 저장, 할당하고 객체는 참조를 저장, 할당 한다. JS의 이러한 작동 방식을 바꿀 수 있는 방법은 없다.

<br>

## A.2 다양한 형태의 함수

```js
var awesomeFunction = function (coolThings) {
  // ...
  return amazingStuff;
};
```

function 키워드와 매개변수가 들어갈 괄호 (...) 사이에 함수 이름을 나타내는 식별자가 없으므로 여기에 쓰인 함수 표현식은 익명 함수 표현식이 된다. ES6 등장 후 이 지점에서 많은 사람들이 혼동을 느끼는데, JS는 익명 함수이더라도 다음과 같이 자체적으로 **이름을 추론**하기 때문이다.

```js
awesomeFunction.name;
// "awesomeFunction"
```

함수명을 직접 명시했을 때 함수의 name 프로퍼티에 접근하면 지정한 이름을 볼 수 있다. 익명 함수 표현식에서도 name 프로퍼티에 접근하면 추론된 이름이 나타난다. 개발자는 이 기능을 활용해 함숫값을 검사하거나 스택 트레이스에서 오류가 발생한 함수를 찾을 수 있다.

이렇듯 익명 함수 표현식이라 할지라도 이름이 **있을 수** 있다. 다만 JS의 이름 추론은 할당 현산자(=)를 사용해 함수 표현식을 할당한 것 같은 제한적인 상황에서만 발생한다. 함수 표현식을 인수로 전달하며 함수를 호출하는 경우에는 이름 추론이 발생하지 않는다. 이 경우에 name 프로퍼티는 빈 문자열이 되고 개발자 도구 콘솔에는 (anonymous function)이 출력된다.

추론을 통해 이름을 부여받긴 해도 익명 함수는 여전히 익명 함수이다. 추론된 이름은 문자열 형태의 메타데이터일 뿐, 해당 함수를 참조하는 유효한 식별자가 아니기 때문이다. 익명 함수는 본문 안에서 자기 자신을 참조할 수 있는 식별자를 갖지 못한다. 이런 특징은 재귀를 사용하거나 등록된 이벤트를 해제할 때 문제가 된다.

앞서 살펴본 익명 함수 표현식과 아래 예제를 비교해보면

```js
// let awesomeFunction = ...
// const awesomeFunction = ...
var awesomeFunction = function someName(coolThings) {
  // ...
  return amazingStuff;
};

awesomeFunction.name;
// "someName"
```

이렇게 코드를 작성하면 컴파일 중에 식별자 someName과 함수 표현식에 직접적인 연관 관계가 생긴다. 즉 이 함수 표현식은 기명 함수 표현식이 된다. 다만 식별자 `awesomeFunction`과의 연관 관계는 해당 구문이 실행될 때(런타임)까지는 발생하지 않는다. 두 식별자가 꼭 같아야 할 필요는 없고, 상황에 따라 식별자가 달라야 한다면 다르게, 같아야 한다면 같게 코드를 작성하면 된다.

기명 함수 표현식을 다룰 때 직접 지정한 이름(식별자 `someName`)은 `name`프로퍼티를 사용해 지정한 이름보다 우선순위가 높다.

그렇다면 기명 함수 표현식을 사용하는게 좋을까 익명 함수 표현식을 사용하는게 좋을까? 의견은 다양하지만 대부분이 익명 함수 표현식을 사용한다. 익명 함수 표현식이 기명 함수 표현식보다 더 짧고 JS 생태계에서는 익명 함수 표현식이 더 일반적이기 때문이다.

상황은 이렇지만 필자는 프로그램 내에 있는 함수는 목적이 있어야 한다며 기명 함수 표현식을 사용해 자연스러운 이름을 부여해야 한다고 한다.

함수 선언 방식 중 일부

```js
// 제너레이터 함수 선언
function *two() { ... }

// async 함수 선언
async function three() { ... }

// async 제너레이터 함수 선언
async function *four() { ... }

// 기명 함수 내보내기 선언(ES6 모듈)
export function five() { ... }
```

함수 표현식 방식 중 일부

```js
// IIFE(즉시 실행 함수 표현식)
(function() { ... })();
(function namedIIFE(){ ... })();

// 비동기 IIFE
(async function(){ ... })();
(async function namedAIIFE(){ ... })();

// 화살표 함수 표현식
var f;
f = () => 42;
f = x => x * 2;
f = (x) => x * 2;
f = (x, y) => x * y;
f = x => ({ x: x * 2 });
f = x => { return x * 2; };
f = async x => {
  var y = await doSomethingAsync(x);
  return y * 2;
};
someOperation( x => x * 2 );
// ...
```

화살표 함수 표현식을 다룰 때는 함수 식별자가 될 이름을 직접 지정할 방법이 없으므로 화살표 함수 표현식은 문법적으로 익명이 될 수 밖에 없다. 이름 추론이 작동하면서 이름이 부여되는 경우가 있긴 하지만 할당 연산자를 사용한 방식에서만 유효할 뿐, 코드의 마지막 줄 함수처럼 인수로 화살표 함수를 넘기는 방식(자주 쓰이는 형태)에서는 이름이 부여되지 않는다.

화살표 함수는 특별한 목적(this 키워드가 참조하는 렉시컬 환경을 핸들링하기 등)을 갖고 있다는걸 알고 있도록 하자.

클래스나 객체 리터럴을 정의할 때도 함수를 정의할 수 있다. 이런 형태의 함수는 특별히 **메서드**라고 부르며 JS에서 "함수"와 "메서드" 사이에 큰 차이는 없다.

```js
class SomethingKindaGreat {
  // 클래스 메서드
  coolMethod() { ... } // 쉼표가 없다.
  boringMethod() { ... }
}

var EntirelyDifferent = {
  // 객체 메서드
  coolMethod() { ... } // 쉼표가 있다.
  boringMethod() { ... },

  // (익명) 함수 표현식의 프로퍼티
  oldSchool: function() { ... }
};
```

함수 선언 방식을 전부 외울 순 없고, 개발자라면 작업 중인 코드베이스를 기준으로 어떻게 함수를 정의했는지 살펴보고, 적절한 형태로 함수를 가져다 쓸 수 있도록 함수 선언 방법을 숙지하도록 하자.

<br>

## A.3 강제 조건부 비교

강제 조건부 비교란 무엇일까? 조건에 맞는지 아닌지를 판단하려면 강제 변환이 선행되어야 하는 조건부 표현식에 대해 배워보자.

`if`와 `?`, `:` 가 연달아 나오는 삼항 조건부 연산자 그리고 `while`과 `for` 반복문의 조건절은 암시적으로 값을 비교한다. 비교에는 타입이 같은지도 확인하는 엄격비교가 있고, 강제로 타입을 전환해 비교하는 경우도 있다. 그렇다면 강제 조건부 비교는 어떤 비교 방식을 따르는 것일까? 답은 둘 다 이다.

예시를 살펴보면

```js
var x = 1;

if (x) {
  // 코드가 실행된다.
}

while (x) {
  // 코드가 딱 한번 실행된다
  x = false;
}
```

위 예시를 봤을 때, x 관련 조건부 표현식을 아래처럼 치환해서 생각했을 것 이다.

```js
var x = 1;

if (x == true) {
  // 코드가 실행된다
}

while (x == true) {
  // 코드가 딱 한 번 실행된다
  x = false;
}
```

x가 1인 경우 같은 특정한 사례에서는 이런 멘탈 모델이 잘 작동한다. 하지만 이 방법은 모든 경우에 사용할 수는 없다.

```js
var x = "안녕하세요.";

if (x) {
  // 코드가 실행된다.
}

if (x == true) {
  // 코드가 실행되지 않는다.
}
```

위와 같은 경우 원하는 대로 동작하지 않는다.

```js
var x = "안녕하세요.";

if (Boolean(x) == true) {
  // 코드가 실행된다.
}

// 이렇게 치환해도 괜찮다.
if (Boolean(x) === true) {
  // 코드가 실행된다.
}
```

함수 `Boolean()`은 항상 불리언 타입의 값을 반환하므로 `==`를 쓰든 `===`를 쓰든 상관없이 결과는 같다. 중요한 것은 비교하기 전에 강제 변환이 일어나고, `x`는 타입에 상관없이 불리언 값이 된다는 점이다.

JS에서는 비교와 강제 변환을 분리해서 생각할 수 없다.

<br>

## A.4 프로토타입 클래스

프로토타입 연결 장치를 사용하는 방법을 프로토타입 클래스라 부른다. ES6에서 객체를 연결해주는 클래스 시스템이 등장하기 전까지 프로토타입 클래스는 객체를 연결하는 역할을 했다.

`Object.create()`를 사용한 예시를 살펴보자

```js
var Classroom = {
  welcome() {
    console.log("환영합니다!");
  },
};

var jsClass = Object.create(Classroom);

jsClass.welcome();
// 환영합니다!
```

예시에서 객체 `jsClass`는 프로토타입을 통해 객체 `Classroom`과 연결된다. 두 객체가 연결되어 있기 때문에 함수 `mathClass.welcome()`을 호출하면 위임이 일어나면서 `Classroom`에 정의되어 있는 메서드가 호출된다.

프로토타입 클래스 패턴에서는 이런 방식의 위임을 상속이라고 부른다. 프로토타입을 사용한 상속은 다음과 같이 정의할 수도 있다.

```js
function ClassRoom() {
  // ...
}

Classroom.prototype.welcome = function hello() {
  console.log("환영합니다!");
};

var jsClass = new Classroom();

jsClass.welcome();
// 환영합니다!
```

모든 함수는 기본적으로 `prototype`이라는 프로퍼티를 통해 빈 객체를 참조한다. `prototype`이름의 프로퍼티는 함수의 프로토타입(프로토타입을 통해 함수와 연결된 객체)과는 다르다. 프로퍼티인 `prototype`은 `new`를 사용해 함수를 호출해 객체를 만들었을 때, 새롭게 만든 객체의 프로토타입을 설정할 수 있도록 한다.

예시에서는 빈 객체(`Classroom.prototype`)에 `welcome`이라는 프로퍼티를 추가하고, `welcome` 프로퍼티가 함수 `hello()`를 가리키도록 했다. 그리고 `new Classroom()`으로 새로운 객체(`mathClass`에 할당함)를 만들어, 이 객체의 프로토타입이 기존 객체인 `Classroom.prototype`이 되도록 했다.

`jsClass`에는 `welcome()`이라는 프로퍼티나 함수가 없지만, `prototype` 프로퍼티 덕분에 `classRoom.prototype.welcome()`에 성공적으로 위임되었다.

프로토타입 클래스 패턴보다는 ES6의 클래스 메커니즘을 쓰는게 훨씬 낫긴하다.

```js
class Classroom {
  constructor() {
    // ...
  }

  welcome() {
    console.log("환영합니다!");
  }
}

var jsClass = new Classroom();
jsClass.welcome();
//환영합니다!
```

클래스 메커니즘과 프로토타입 클래스 모두 저 밑바닥에서는 동일한 프로토타입 연결 장치로 설정되어 있다. 하지만 클래스 지향 디자인 패턴에는 "프로토타입 클래스"보다 클래스가 훨씬 잘 맞는다.
