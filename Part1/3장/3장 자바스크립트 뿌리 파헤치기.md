# 3장 자바스크립트 뿌리 파헤치기

## 3.1 이터레이션

소프트웨어는 데이터를 처리하기 위해 만들어졌고, 데이터를 처리하는 데 사용하는 패턴은 코드 전체의 가독성에 큰 영향을 미친다.

이터레이션 패턴은 데이터를 덩어리 단위로 표준화된 방법을 사용해 각각 처리할 수 있다.

이터레이터 패턴의 이런 접근 방식은 데이터 전체를 한꺼번에 처리하기 보다 데이터를 일정 단위로 쪼개고, 쪼갠 조각들을 차례대로 순회하며 점진적으로 처리하면 범용적이고 유용할거라는 아이디어에서 출발했다.

이터레이터 패턴의 핵심은 반복 작업으로 데이터를 처리할 때 표준화된 방법을 제공한다는 점이다. 처리해야 할 데이터 컬렉션의 형태가 다르면 반복 작업에 사용되는 코드도 제각각이 될 수 밖에 없기에 이터에터 패턴을 사용하면 깔끔하고 이해하기 쉬운 코드로 반복 작업을 수행할 수있다.

JS 커뮤니티에서 이터레이터 패턴을 추가하려고 노력했고 그결과 ES6 명세서에 내장문법을 통해 이터레이터 패턴을 구현하는 구체적인 프로토콜이 추가됐다. 이 프로토콜에서 next() 메서드는 이터레이터 리절트라 불리는 객체를 반환하고 이터레이터 리절트 객체에는 value와 done이라는 프로퍼티가 있어야 한다고 규정한다.

또한 반복 작업이 끝나지 않은 경우, done에는 불리언 값 false가 저장되어야 한다.

### 3.1.1 이터레이터 소비하기

ES6에서 정의한 이터레이션 프로토콜을 사용하면 데이터를 한 조각씩 순차적으로 처리한다.

next() 호출 반환값인 이터레이터 리절트 객체의 done 프로퍼티가 true라면 반복 작업이 중단된다. 하지만 이 방식은 다소 품이 들기에 ES6에서는 for…of 반복문 같은 새로운 문법과 API를 새롭게 정의해 표준화 된 방법으로 이터레이트 리절트 객체를 소비할 수 있다.

```jsx
//처리하려는 데이터의 이터레이터
const it = /*... */

for (let value of it) {
	console.log(`이터레이터 값: ${value}`);
}
//콘솔에 아래와 같은 메시지가 출력된다
//이터레이터 값:~~~
//이터레이터 값:~~~
```

for…of 반복문 말고도 표현식 …을 사용하면 이터레이터를 소비할 수있다. …은 대칭 형태인 전개 구문과 나머지 매개변수를 이용해 사용한다. 이때 전개 구문이 바로 이터레이터를 소비하는 주체인 이터레이터 소비자이다.

```jsx
//이터레이터를 펼친 결과가 배열의 각 요소가 되도록 한다.
const values = [...it];

//이터레이터를 펼친 결과를 함수 호출문에 넘겨 각 값을 인수로 사용할수 있다.
doSomethingUseful(...it);
```

전개 구문과 나머지 매개변수에서 사용되는 표현식 …은 이터레이터 소비 프로토콜을 준수하고, 그 결과로 이터레이터에서 원하는 값을 추출해 배열이나 인수 목록 같이 원하는 곳에 값을 할당할 수 있다.

### 3.1.2 이터러블

이터레이터 소비 프로토콜은 순회 가능한 값인 이터러블을 소비하는 기술적인 방법이라고 정의할 수 있다.

JS에서는 문자열, 배열, 맵, 셋 같이 기본이 되는 자료 구조나 컬렉션을 이터러블로 정의한다.

배열과 문자열처럼 간단한 이터러블도 있지만 맵은 앞의 둘과 좀 다르게 기본 이터레이터를 지원한다.

Map의 내장 메서드 entries를 호출하면 맵의 값 뿐만 아니라 키까지 포함한 2차원 배열인 entry 튜플을 순회할 수 있다.

```jsx
//DOM 요소 btn1과 btn2가 있다고 가정한다.

const buttonNames = new Map();
buttonNames.set(btn1, "버튼 1");
buttonNames.set(btn2, "버튼 2");

for (let [btn, btnName] of buttonNames) {
	 btn.addEventListener(click", function onClick() {
		 console.log(`${btnName}을 클릭했습니다.`);
	});
}

```

for…of 반복문은 맵이 지원하는 기본 이터레이터를 순회하며 구조 분해문법을 사용해 튜플을 키, 값으로 분해하고 할당한다.

좀더 정교한 이터레이션이 필요할때, 예를 들어 앞의 예시에서 buttonNames에서 값만 추출하고싶으면 아래와 같이 사용할수있다.

```jsx
for (let btnName of buttonnames.values()) {
  consolo.log(btnName);
}
//버튼1
//버튼2
```

또한 배열의 인덱스와 값을 대상으로 순회하고 싶다면 아래와 같이 entries() 메서드를 사용할 수있다.

```jsx
const arr = [10, 20, 30];

for (let [idx, val] of arr.entries()) {
  console.log(`${idx}: ${val}`);
}
//[0]: 10
//[1]: 20
//[2]: 30
```

위와 같이 js의 내장 이터러블은 키(`keys()`), 값(`values()`), 키와 값 함께(`entries()`) 순회하는 메서드를 제공한다.

<br />

## 3.2 클로저

클로저는 JS를 지탱하는 근본적인 기술로 반복문만큼 클로저를 이해하는게 중요하다.

클로저란 함수가 정의된 스코프가 아닌 다른 스코프에서 함수가 실행되더라도, 스코프 밖에 있는 변수를 기억하고 이 외부 변수에 계속 접근할 수 있는 경우를 의미한다.

여기서 클로저만의 특징은 아래와 같다.

- 클로저는 함수의 타고난 특징이다
  객체는 클로저가 되지않지만 함수는 자연스럽게 클로저가 된다.
- 클로를 직접 보고 싶다면 함수를 해당 함수가 정의된 스코프가 아닌 다른 스코프에서 실행해야한다.

```jsx
function greeting(msg) {
	return funciotn who(name) {
		console.log(`${name}님 ${msg});
	}
}

const hello = greeting("안녕하세요");
const howdy = greeting("잘 지내나요?");
hello("서하"); //서하님 안녕하세요
howdy("기원"); //기원님 잘 지내나요?
```

**위의 예시 코드 실행과정을 좀 쉽게 설명하면 아래와 같다**

함수 **greeting(msg)** 호출:

- **greeting** 함수는 문자열 **msg**를 매개변수로 받는다.
- 이 함수는 또 다른 함수 who(name)를 정의하고 반환한다.
- 반환된 **who** 함수는 **greeting** 함수의 매개변수 **msg**를 사용할 수 있는 클로저가 된다.

클로저 생성:

- greeting("안녕하세요")를 호출하면, **who** 함수가 생성되며, 이 함수는 "안녕하세요"라는 메시지를 클로저로 갖게 된다.
- 이렇게 생성된 **who** 함수는 **hello** 변수에 저장된다.
- 다시 greeting("잘 지내나요?")를 호출하면, 새로운 **who** 함수가 생성되며, "잘 지내나요?"라는 메시지를 갖게 된다.
- 이 함수는 **howdy** 변수에 저장된다.

클로저 활용:

- hello("서하")를 호출하면, **hello**에 저장된 **who** 함수가 실행되며, "서하님 안녕하세요"가 출력된다. 이 때 **who** 함수는 첫 번째 **greeting** 호출에서 받은 "안녕하세요"를 사용한다.
- howdy("기원")를 호출하면, **howdy**에 저장된 **who** 함수가 실행되며, "기원님 잘 지내나요?"가 출력된다. 이 때는 두 번째 **greeting** 호출에서 받은 "잘 지내나요?"를 사용한다.

각각의 **greeting** 호출은 독립된 환경을 생성하며, 각 환경에서 생성된 **who** 함수는 자신이 생성될 때의 환경을 "기억"한다. 이를 통해 같은 형태의 함수라도 각각 다른 상태를 유지할 수 있다.

```jsx
function conter(step = 1) {
  var count = 0;
  return function increaseCount() {
    count = count + step;
    return count;
  };
}

var incBy1 = counter(1);
var incBy3 = counter(3);

incBy1(); //1
incBy1(); //2

incBy3(); //3
incBy3(); //6
incBy3(); //9
```

**위의 예시 코드 실행과정을 좀 쉽게 설명하면 아래와 같다**

**함수 counter(step = 1) 정의:**

- **counter** 함수는 매개변수로 **step**을 받으며, 기본값으로 **1**이 설정되어 있다.
- 함수 내부에 지역 변수 **count**가 **0**으로 초기화된다.
- 이 함수는 내부 함수 **increaseCount()**를 정의하고 반환한다.
- 반환된 **increaseCount** 함수는 **count** 변수를 **step**만큼 증가시키고, 증가된 **count** 값을 반환하는 클로저다.

**클로저 생성:**

- **counter(1)**을 호출하면, **step** 값으로 **1**을 사용하여 **increaseCount** 클로저가 생성된다. 이 클로저는 **count**를 **1**씩 증가시킨다.
- 생성된 **increaseCount** 함수는 **incBy1** 변수에 저장된다.
- **counter(3)**을 호출하면, **step** 값으로 **3**을 사용하여 새로운 **increaseCount** 클로저가 생성된다. 이 클로저는 **count**를 **3**씩 증가시킨다.
- 생성된 또 다른 **increaseCount** 함수는 **incBy3** 변수에 저장된다.

**클로저 활용:**

- **incBy1()**을 첫 번째로 호출하면, **incBy1**에 저장된 **increaseCount** 함수가 실행되어 **count** 값을 **1**만큼 증가시키고, 결과로 **1**을 반환한다.
- **incBy1()**을 두 번째로 호출하면, 같은 함수가 다시 실행되어 **count**를 누적하여 **1**만큼 더 증가시키고, 결과로 **2**를 반환한다.
- **incBy3()**을 첫 번째로 호출하면, **incBy3**에 저장된 **increaseCount** 함수가 실행되어 **count** 값을 **3**만큼 증가시키고, 결과로 **3**을 반환한다.
- **incBy3()**을 두 번째로 호출하면, 같은 함수가 다시 실행되어 **count**를 누적하여 **3**만큼 더 증가시키고, 결과로 **6**을 반환한다.
- **incBy3()**을 세 번째로 호출하면, 같은 함수가 다시 실행되어 **count**를 누적하여 **3**만큼 더 증가시키고, 결과로 **9**을 반환한다.

각각의 **counter** 호출은 독립된 환경을 생성하며, 생성된 각 환경에서의 **increaseCount** 함수는 자신이 생성될 때의 환경을 "기억"하고, **count**와 **step**을 유지한다. 이를 통해 각 함수 호출 시마다 해당 함수에 설정된 **step**에 따라 **count**가 증가된다.

클로저는 콜백과 같이 비동기 작업을 수행하는 코드에서 가장 흔히 찾아볼 수 있다.

```jsx
function getSomeDate(url) {
  ajax(url, function onResponse(resp) {
    console.log(`${url}에서 온 응답: ${resp}`);
  });
}

getSomeData("https://word2markdown.com");
//https://word2markdown.com에서 온 응답:....
```

내부 함수 onResponse()는 url을 에워싸기 때문에 Ajax 호출이 완료되고 그 결과 onResponse() 콜백 함수에 의해 처리될 때까지 url을 보존하고 기억한다.

이때 getSomeData() 가 곧바로 실행 종료되더라도 특별한 이유가 없다면 매개변수 url을 통해 받은 값은 클로저 안에 보존된다.

외부 스코프가 항상 함수여야 하는건 아니지만, 보통 내부 함수에서 하나 이상의 외부 스코프 변수에 접근하려 할 때 클로저를 관찰할 수 있다.

```jsx
for (let [idx, btn] of buttons.entries()) {
  btn.addEventListener("click", function onClick() {
    console.log(`${idx}번째 버튼을 클릭했다`);
  });
}
```

위의 예시에서 반복이 일어날 때마다 변수 idx와 btn은 새로운 블록 스코프에 정의된다. 또한 반복문이 실행될 때 새로운 내부 함수인 onClick이 만들어지고, 이 내부 함수는 idx를 에워싸서 클릭 이벤트 핸들러가 btn에 할당된 동안 idx를 보존한다. 그 덕분에 특정 버튼을 클릭할때 버튼 순서에 맞는 인덱스 값을 출력할수 있다.

클로저는 모든 언어에서 사용되는 가장 보편적이고 중요한 프로그래밍 패턴이다.

## 3.3 this 키워드

JS를 지탱하는 가장 강력한 메커니즘인 this 키워드는 가장 오해를 많이 받는 메커니즘인데, 함수에서 this가 가리키는 것이 함수 자기 자신이라는것 역시 많이 알려진 오해이다.

함수는 정의되는 시점에 클로저를 통해 함수를 에어쒀난 스코프에 부착되는데 여기서 스코프는 변수가 어떤 것을 참조하는지를 결정하는 규칙 모음이다. 함수는 스코프 말고도 자신이 어디까지 접근 가능한지를 결정하는 함수만의 특징을 갖는데, 이 특징은 실행 컨텍스트 개념으로 가장 잘 설명되며 함수는 this 키워드를 통해 실행 컨텍스트에 접근한다.

스코프는 정적이며 함수를 정의하는 순간, 해당 스코프에서 사용할 수 있는 한정된 변수 집합을 포함 한다. 반면 함수 실행 컨텍스트는 동적으로 함수를 정의한 위치나 함수를 호출하는 위치와 상관없이 함수 호출 방식에 따라 결정된다.

즉, this는 함수의 정의에 종속되어 결정되는 특성이 아니라, 함수를 호출할 때 결정되는 동적인 특성이다.

실행 컨텍스트는 함수가 실행되는 동안 함수에서 사용할 수 있는 프로퍼티를 가진 유형의 객체로 생각하면 이해하기 쉽다.

```jsx
function classroom(teacher) {
  return function study() {
    console.log(`${teacher} 선생님이 ${this.topic}를 공부하라고 했습니다.`);
  };
}

const assignment = classroom("한민지");
```

예시에서 외부 함수 **classroom()**에는 this 키워드를 참조하지 않는데 내부함수 study()에는 this가 있다.

이렇게 this가 있는 함수는 실행 컨텍스트에 종속되므로 함수를 제대로 이해하려면 this와 실행 컨텍스트의 작동 방식을 알아야햔다.

```jsx
assignment();
//한민지 선생님이 undefined를 공부하라고 했습니다.
```

구체적인 컨텍스트를 지정하지 않고 실행하게되면 기본 컨텍스트가 전역 객체가 되고 전역에는 topic이라는 변수가 없고, 전역 객체에 topic이라는 프로퍼티 또한 없기에 undefined가 됐다.

```jsx
const homework = {
  topic: "JS",
  assignment: assignment,
};

homework.assignment();
//한민지 선생님이 JS를 공부하라고 했습니다.

const otherHomework = {
  topic: "React",
};

assignment.call(otherHomework);
//한민지 선생님이 React를 공부하라고 했습니다.
```

위의 예시에서 **assignment** 함수의 참조 복사본 **homework** 객체의 프로퍼티로 설정하고 호출하면 this가 **homework** 객체가 된다.

또한 아래 예시에서 함수를 호출할 때 this가 참조하는 객체를 결정하는 call메서드를 사용해 **assignment**함수를 샐행하면 **this.topic**은 “React”를 참조한다.

함수에서 this를 사용하면 컨텍스트를 동적으로 지정할 수 있고, 다른 객체에도 함수를 재사용 할수 있어서 매우 유연하다. 스코프가 지정된 함수는 다른 스코프를 참조할 수 없고 변수를 지정할 수도 없다.

하지만 this를 사용하면 동적으로 컨텍스트를 지정할 수 있으므로 매우 유용하다.

## 3.4 프로토타입

this가 함수 실행에 관한 특징이라면 프로토타입은 객체, 구체적으로 프로퍼티에 접근할 때 일어나는 동작과 관련된 특징이다.

프로토타입은 두 객체를 연결하는 연결 장치로 이때 이 연결 장치는 숨겨져 있어서 보이지 않는다. 하지만 몇가지 방법을 사용하면 연결장치를 관찰할 수 있다. 프로토타입이라는 연결 장치는 객체가 생성될 때 만들어지고, 새롭게 생성된 객체는 기존에 존재하는 다른 객체에 연결이 된다.

프로토타입을 통해 연결된 일련의 객체는 프로토타입 체인이라고 부른다.

객체B에서 다른 객체 A를 연결할 수 있게 하는 프로토타입 연결 장치가 존재하는 이유는 B에 없는 프로퍼티 메서드에 접근하려 할때, 객체 A에서 위임을 받아 해당 접근을 처리할 수 있도록 하기 위해서이다. 이런 식으로 프로퍼티 메서드 접근 권한을 위임하면 두개 이상의 객체가 서로 협력하며 작업할 수 있다.

```jsx
const homework [ {
	topic: "JS"
};
```

**homework** 객체에는 topic이라는 프로퍼티만 있지만 기본 프로퍼티 연결 장치가 **Object.prototype** 객체를 연결하므로 **Object.prototype**에 있는 내장 메서드 **toString()**이나 **valueOf()**등의 메서드를 **homework**에서도 사용 할 수있다.

### 3.4.1 객체 연결 장치

객체 연결 체계를 이해하기 위해서는 **Object.create()** 함수를 살펴볼 필요가 있다. 이 함수는 새로운 객체를 생성하면서 기존 객체를 프로토타입으로 설정하여, 객체 간의 상속과 연결을 가능하게 한다.

```jsx
const homework = {
  topic: "JS",
};

const otherHomework = Object.create(homework);
otherHomework.topic = "JS";
```

위 코드에서 **otherHomework** 객체는 **Object.create(homework)**를 통해 **homework** 객체를 상속받는다. 이렇게 생성된 **otherHomework** 객체는 **homework**의 프로퍼티와 메서드를 상속받아 사용할 수 있다. **otherHomework**에 **topic** 프로퍼티를 직접 할당하면, 이 프로퍼티는 **otherHomework**에 직접 존재하게 된다.

이 연결 방식의 핵심은 프로토타입 체인이다. 프로토타입 체인을 통해 객체는 자신에게 없는 프로퍼티나 메서드에 접근할 때 프로토타입 체인을 따라 상위 객체에서 해당 프로퍼티나 메서드를 찾아 사용할 수 있다. 이런 방식으로 JavaScript는 상속을 구현한다.

```jsx
console.log(otherHomework.topic); // "JS"
```

**otherHomework.topic**을 출력하면 "JS"가 출력된다. 이는 **otherHomework** 객체에 **topic** 프로퍼티가 직접 정의되어 있기 때문이다. 만약 **otherHomework**에서 **topic** 프로퍼티를 삭제하면, **homework** 객체의 **topic**이 출력된다.

이렇게 **Object.create()**를 사용하는 방법은 새로운 객체를 만들 때 명시적으로 프로토타입을 지정할 수 있으며, 프로토타입 체인을 통해 객체 간의 상속과 메서드 재사용이 가능하게 한다. 이 방식은 기존 객체를 확장하거나 수정하지 않고도 새로운 객체를 유연하게 생성할 수 있는 강력한 도구를 제공한다.

### 3.4.2 this 다시보기

**this** 키워드는 함수 호출 시의 컨텍스트를 동적으로 바인딩하는 특징을 가진다. 함수가 어떤 방식으로 호출되었는지에 따라 **this** 값이 결정된다. 가장 흔한 경우, 메서드로써의 함수 호출은 **this**가 호출 주체인 객체를 가리킨다. 그러나 함수가 어떤 방식으로 호출되었는지에 따라 **this** 값이 달라진다.

```jsx
const homework = {
  study() {
    console.log(`${this.topic} 공부를 해주세요.`);
  },
};

const jsHomework = Object.create(homework);
jsHomework.topic = "JS";
jsHomework.study(); // "JS 공부를 해주세요."

const mathHomework = Object.create(homework);
mathHomework.topic = "수학";
mathHomework.study(); // "수학 공부를 해주세요."
```

**jsHomework**와 **mathHomework** 객체는 **Object.create(homework)**를 통해 **homework** 객체에서 메서드 **study()**를 상속받는다.

**study()** 메서드 내부에서 **this.topic**은 해당 객체의 **topic** 속성을 참조한다. 이로 인해 각 객체의 **topic** 값에 따라 다른 출력 결과가 나타난다.

이 예제에서 **this**는 호출된 메서드가 속해 있는 객체, 즉 **jsHomework**나 **mathHomework**를 참조한다. **this** 값은 메서드 호출 시 결정되므로, 같은 메서드라도 다른 객체에서 호출하면 **this**가 가리키는 대상이 달라진다.

다른 예로 함수 내에서 **this**를 고정하기 위해 **bind** 메서드를 사용할 수 있다. 이 방법은 주로 함수가 예상치 못한 방식으로 호출될 때 **this**가 예상한 객체를 계속 참조하도록 보장한다. 또한 클래스에서 메서드를 정의할 때 **this**가 클래스 인스턴스를 계속 참조하도록 하는 것이 일반적이다.

이렇게 **this**는 JavaScript에서 매우 유연하게 사용될 수 있으며, 함수의 호출 방식에 따라 그 의미가 달라진다. 이는 함수의 재사용성을 높이고, 다양한 컨텍스트에서 같은 함수를 효과적으로 활용할 수 있게 한다.
