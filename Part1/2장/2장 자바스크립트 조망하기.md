# 2장 자바스크립트 조망하기

# 자바스크립트 조망하기

## 2.1 파일은 프로그램입니다.

웹사이트나 웹 애플리케이션은 수많은 JS 파일로 구성되어 있어, 웹사이트 하나 혹은 애플리케이션 하나를 단일 프로그램으로 생각하기 쉽지만, 실제로는 각 파일이 별도의 프로그램으로 작동한다.

독립적인 JS 파일 여러 개를 하나의 프로그램으로서 작동시키는 유일한 방법은 전역 스코프를 사용하여 파일 간 상태를 공유하고, 공통으로 사용하는 기능에 접근할 수 있도록 만드는 것이다. 이러한 방식으로 전역 스코프 네임스페이스에서 여러 JS 파일이 조합되면, 이 파일들은 런타임에서 하나의 애플리케이션으로 작동한다.

ES6 이후로 JS는 기존의 독립형 JS 프로그램 포맷 외에도 모듈 포맷을 지원하며, 모듈 역시 파일 기반이라는 특징을 가진다.

파일을 'import' 문이나 **<script type="module">** 태그를 통해 불러올 경우, 이는 하나의 모듈로서 처리된다.

JS는 각 모듈을 별도로 처리하며, 한 모듈을 불러오면 런타임에서 다른 모듈과 상호작용할 수 있다.

하지만 파일이든 모듈이든, 각 파일은 제3의 작고 독립적인 프로그램과 협력하여 프로그램 전체를 작동시키는 고유한 작은 프로그램으로 생각해야 한다.

## 2.2 값

프로그램에서 가장 기본적인 단위는 값이고 JS에서 값은 크게 원시 타입과 객체 차입으로 분류된다.

JS에서은 리터를을 사용해 프로그램에 값을 주입한다

- 리터럴이란??
  리터럴(literal)은 자바스크립트와 같은 프로그래밍 언어에서 소스 코드에 직접 나타나는 고정된 값으로, 리터럴을 사용하면 변수나 상수에 할당할 수 있는 값들을 직접적으로 표현할 수 있다. 예를 들어, 아래와 같은 종류의 리터럴이 있다:
  1. **숫자 리터럴**: **10**, **3.14**, **500**
  2. **문자열 리터럴**: **"안녕하세요"**, **'hello'**
  3. **논리적 리터럴 (boolean)**: **true**, **false**
  4. **배열 리터럴**: **[1, 2, 3]**
  5. **객체 리터럴**: **{ name: "Jane", age: 22 }**
  6. **함수 리터럴**: **function() {}** 또는 화살표 함수 **(a, b) => a + b**
     리터럴은 코드 내에서 값을 직접 표현하는 간단하고 효율적인 방법을 제공한다.

```jsx
greeting(”제 이름은 성한 입니다.”)
```

위의 예시에서 “제 이름은 카일 입니다.”라는 값은 원시 문자열 리터럴이다.

참고로 문자열은 문자를 모아놓은 집합으로, 보통 단어나 문장을 표현하는 용도로 사용한다.

예시에서는 문자열의 범위를 큰따옴표로 정하였는데 작은따옴표를 사용해 문자열 범위를 정의할 수도 있다. 어떤 표기법을 사용할지는 전적으로 개인의 취향에 따라 달라지지만 코드 가독성과 유지 보수를 위해 일관성 있는 표기법을 사용해야한다.

또한 문자열 범위를 정할 때 따옴표가 아니라 백틱을 사용할 수 있는데 아래와 같이 백틱으로 감싼 문자열에는 변수 표현식인 `${…}` 부분이 현재값(성한)으로 대체되는 보간법을 사용한다.

```jsx
const firstName = "성한";

console.log(`제 이름은 ${firstName}입니다.`);
//제 이름은 성한입니다.
```

물론 보간법 없이 사용할 수도 있지만 백틱이 만들어진 목적과 부합하지 않기에 권장하지않는다.

JS에는 문자열 말고 불리언이나 숫자 같은 원시 리터럴 값을 사용할 수 있다.

```jsx
while (false) {
  console.log(3.141592);
  console.log("아... 배고파...너무 너무 배고파...");
}
```

while은 반복문의 종류로, 조건식이 참일 경우 {}안의 작업을 반복할 때 사용한다.

예시에서는 조건식이 false이므로 반복하지 않고 아무것도 콘솔에 찍히지 않는다.

또한 숫자 3.141592는 원주율의 근사값으로, 이렇게 값이 확정된 경우 값을 직접 작성하기 보다 Math.PI같이 이미 정의된 값을 가져다 쓰는게 좋다.

또한 숫자중 아주 큰 정수를 나타낼 때는 원시 타입 bigint를 사용한다.

JS는 문자열, 숫자, 불리언 이외에도 null과 undeined라는 원시타입을 지원하고 **null**과 **undefined**는 모두 "값이 없음"을 나타내지만, **undefined**는 변수가 선언되었으나 아직 어떤 값으로도 초기화되지 않았을 때나 값을 할당하지 않으면 자동으로 **undefined**가 할당되고 **null**은 변수에 값이 없다는 것을 의도적으로 명시할 때 사용하는 리터럴 값이다.

마지막으로 심벌이 있는데 심벌은 사람이 추측할 수 없게 만든 특수한 숨김값으로 주로 객체에서 특정한 키를 만들때 사용된다.

```jsx
hitchikersGuide[Symbol("삶의 의미")];
//42
```

일반적인 JS프로그램에서는 심벌이 거의 사용되지않고 라이브러리나 프레임 워크같이 좀 더 저차원 코드에서 사용된다.

### 2.2.1 배열과 객체

JS에는 원시 타입 말고 객체 타입이 존재하고 그중 배열은 특수한 유형의 객체로, 객체 내 정렬된 데이터에는 숫자 인덱스가 매겨진다.

```jsx
const names = ["성한", "민지", "기원", "성준", "서하"];

names.length;
//5

names[0];
//성한

names[3];
//성준
```

배열에는 원시 타입, 객체 타입 상관 없이 모든 타입의 값이 들어갈 수 있고 배열 안에 배열 역시 가능하다. 또한 함수 역시 값이므로 배열이나 객체의 값에 함수를 할당할 수 있다.

객체는 배열보다 일반적인 데이터 타입으로 정렬되지 않은 키-값 쌍을 모아놓은 컬렉션이다.

배열은 인덱스를 통해 요소에 접근하는 반면 객체는 키를 사용해 요소에 접근한다.

```jsx
const hong = {
  first: "hong",
  last: "sungjun",
  age: "29",
  specialties: ["태클걸기", "잘난척하기"],
};

console.log(`성준이 이름은 ${hong.first}${hong["last"]}입니다.`);
```

위의 예시에서 hong은 객체를 , first는 값이 모여있는 컬렉션인 객체에서 원하는 정보의 위치를 나타낸다.

객체에서 원하는 정보에 접근한은 방식은 예시처럼 온점을 사용하는 방식과 대괄호를 사용하는 방법이 있다.

### 2.2.2 값의 타입

typeof 연산자를 사용해 원시 타입 값과 객체 타입 값을 구분할 수있다.

```jsx
typeof 42; //"number"
typeof "abc"; //"stromg"
typeof true; //"boolean"
typeof undefined; //"undefined"
typeof null; //"object"
typeof { a: 1 }; //"object"
typeof [1, 2, 3]; //"object"
typeof function hello() {}; //"function"
```

위에서 주의해야할 부분은 null의 타입은 null이 아니라 object이다. 또한 function은 타입이 function인데 array는 array가 아니라 object이다.

## 2.3 변수 선언과 사용

변수를 사용하려면 번수 선언이 선행되어야 한다. 식별자라고도 부르는 변수는 다양한 문법으로 선언할 수 있는데, 문법마다 작동 방식이 다르다

```jsx
var adult = true;

if (adult) {
  var myName = "성한";
  var myAge = 31;

  let originName = "기원";
  let originAge = 30;
}

console.log(myName); //"성한"
console.log(originName); //오류~~~~~
```

여기서 var와 let은 프로그램 내에서 사용할 수 있는 변수를 정의한다. 여기에 더해 초기값을 할당할 수 있는 변수를 선언하는 역할도 한다.

다만 여기서 var와 let의 가장 큰 차이는 선언한 변수의 접근 범위에서 차이를 보인다.

var로 선언된 변수의 접근범위는 함수스코프이고 let으로 선언된 변수의 범위는 블록 스코프이다.

- **함수 스코프(Function Scope)**: 함수 내에서 선언된 변수는 해당 함수 내에서만 접근할 수 있다. 함수 밖에서는 그 변수를 볼 수 없다. JavaScript에서 **var** 키워드로 선언된 변수가 이에 해당한다.
- **블록 스코프(Block Scope)**: 블록 스코프는 중괄호 **{}**로 감싸진 코드 블록 내에서 선언된 변수가 그 블록 내에서만 유효하며, 블록 밖에서는 접근할 수 없다. JavaScript의 **let**과 **const**로 선언된 변수들이 블록 스코프를 따른다.

위의 예시에서 보여준 var와 let 말고도 const를 사용해 변수를 선언할 수있다.

const는 let과 유사하지만, 선언되는 순간에 값을 할당해야 하고 나중에 다른 값을 재할당할 수 없다는 차이가 있다.

```jsx
const myBirthday = true;
let age = 31;

if (myBirthday) {
  age = age + 1; //age는 let으로 선언했으므로 값 재할당이 가능하다.
  myBirthday = false; //오류가 발생합니다.
}
```

다만 const로 선언한 변수는 재할당이 불가능할 뿐이지 값을 바꿀수 없는건 아니다.

객체 자체를 재할당하는 건 불가능하지만 값은 바꿀 수 있기 때문이다.

```jsx
const members = ["권성한", "한민지", "최기원", "홍성준", "금서하"];

members[0] = "KEN"; //정상 작동합니다.
members = []; //오류 발생
```

이렇게 var, let, const 말고도 특정 스코프 내에 변수와 같은 식별자를 선언하는 방법이있는데 아래와 같다.

```jsx
function hello(newMember) {
  console.log(`${newMember}님 환영합니다~~`);
}

hello("KEN");
//KEN님 환영합니다~~
```

식별자 hello의 유효 범위는 가장 바깥 ㅅ코프이고 함수를 참조한다. 반면 함수의 매개변수 newMember는 함수 안에서 생성되므로 함수 스코프에서만 접근가능하고 그렇기 때문에 var로 선언한 변수처럼 작동한다.

또한 아래와 같이 catch절을 만들 때 변수가 선언되기도 하는데 catch 절에 전달하는 err의 스코프는 let으로 선언한 변수처럼 블록스코플 갖는다.

```jsx
try {
  someError();
} catch (err) {
  console.log(err);
}
```

## 2.4 함수

JS로 개발할 때 우리는 함수보다 좀 더 포괄적인 개념인 프로시저를 프로그램에 녹여 내기 위해 심사숙고 하며 함수를 작성해야 한다. 여기서 프로시저는 한 번 이상 호출할 수 있고 입력값이 있을수 있으며 하나 이상의 출력값을 반환하는 구문의 모음을 의미한다.

```jsx
function awesomeFunction(coolThings) {
  //.....
  return amazingStuff;
}
```

위와 같은 방식을 함수 선언문이라고 하는데, 함수 선언이란 이름이 함수가 다른 문의 표현식이 아니라 문 자체이기 때문에 붙게 됐다.

함수 선언으로 정의한 awesomeFunction은 식별자 awesomeFunction과 실제 함수를 나타내는 값의 연관이 코드 실행 단계가 아닌 컴파일 단계에서 맺어진다.

함수 선언 말고도 함수 표현식을 사용해 함수를 정의, 할당할 수있다.

```jsx
const awesomeFunction = function (coolThings) {
  //.....
  return amazingStuff;
};
```

위와 같이 함수 표현식으로 선언한 함수가 함수 선언으로 선언한 함수와 다른 점은 함수와 함수 식별자가 코드가 실행되기 전까지는 관계를 맺지 않는다는 점이다.

JS에서 함수는 할당 가능하고 어디든 전달가능한 값이라는 특징이 매우 중요하다. JS에서 함수는 객체의 종류이기에 함수를 값으로 취급하는 게 필수이다.

함수는 매개변수(parameter)를 통해 입력을 받고 매개변수는 함수내에서 지역 변수 역할을 한다.

함수는 0개부터 원하는 개수까지 원하는 만큼 매개변수를 받을 수 있도록 정의할 수 있고 함수를 호출할때는 인수(argument)라 부르는 값을 매개변수에 할당해야한다.

또한 return을 통해서 함수에서 값을 반환할 수 있다. 함수는 하나의 값만 반환할 수 있고 여러개를 반환하고 싶다면 객체나 배열로 반환해야한다.

또한 함수는 값이므로 함수를 객체의 프로퍼티로 할당할 수 있다.

```jsx
const whatToSay = {
  greeting() {
    console.log("안녕하세요");
  },
  question() {
    console.log("이름이 뭔가용?");
  },
  answer() {
    console.log("제이름은 성한퀀입니다");
  },
};

whatToSay.greeting(); //안녕하세요
```

위의 코드에서 세 함수(greeting(), question(), answer())는 whatToSay라는 객체에 종속된다.

각 함수를 호출하려면 객체의 프로퍼티에 접근해 호출하려는 함수의 참조에 접근해야한다.

## 2.5 비교

JS에 비교를 가능하게 하는 몇 가지 메커니즘이 있다.

### 2.5.1 같음에 대한 고찰

JS에서 같음을 비교할 때는 ‘정확하게’ 일치하는지를 따지기도 하지만 때로는 ‘아주 유사하다’ 하거나 ‘교환 가능’한지와 같이 좀 더 넓은 관점에서 비교하는 경우도 있다.

그렇기 때문에 일치 비교와 동등비교의 차이를 알고 있어야 한다.
JS의 등호 세 개가 붙은 형태인 일치 연산자(===)가 있는데 대부분 비교대상이 정확히 같을때 참을 반환하는 연산자라고 예상하지만 NaN이나 -0과 같은 특수한 값과 함께 사용되면 예상과 다르게 작동될수있다.

```jsx
3 === 3.0;           //true
"yes" === "yes";     //true
null === null.       //true
false === false.     //true

42 === "42";        //false
"hello" === "Hello";//false
true === 1;         //false
0 === null;         //false
"" === null;        //false
null === undefined. //false

NaN === NaN;        //false
0 === -0;           //true
```

NaN을 만나면 === 연산자는 거짓말을 한다. NaN과 또다른 NaN은 같지 않다고 말하고 -0이 0과 같다고 거짓말을한다.

그렇기 때문에 NaN과 비교할때는 NumberisNaN()을 사용하고, -0과 비교할때는 Object.is()를 사용해서 비교하는게 좋다.

결론은 === 연산자만으로는 정확한 비교를 할 수 없다는 사실이다.

또한 원시타입이 아닌 객체끼리 비교할 때는 상황이 조금 다르다

```jsx
[1, 2, 3] === [1, 2, 3]      //false
{a: 42} === {a: 42}           //false
(x => x * 2) === (x => x * 2) //false
```

위와 같이 JS에서 객체를 비교할 경우에는 독자성 일치를 비교한다.

JS에서 객체는 참조에 의해 고정되며 참조 복사본을 사용해서 할당 전달된다.그리고 참조를 대상으로 일치 비교가 일어난다.

```jsx
const x = [1, 2, 3];

const y = x;
//참조를 복사한 값이 할당되기 때문에 변수 y는 x의 복사본이 아니라 x와 같은 배열을 참조한다.

y === x; //true
y === [1, 2, 3]; //false
x === [1, 2, 3]; //false
```

위의 예시에서 y와 x가 같은 배열에 대한 참조를 담고있기에 y === x는 true를 반환하지만 나머지는 새로운 배열과 비교가 일어나기 때문에 false를 반환한다. 예시 배열의 내용이 변경되도 결과는 동일하다.

JS에는 객체 구조가 같은지 비교하기위해서는 직접 코드를 작성해서 비교해야한다.

### 2.5.2 강제 변환

강제변환은 타입의 값이 다른 타입의 값으로 변하는걸 의미한다.

JS에서 ==연산자(동등연산자)는 설계가 부실하고 버그가 많다. JS 창시자인 브렌던 아이크조차 동등 연산자 설계에는 실수가 있다고 한탄했다.

근본적인 문제는 동등 연산자가 비교 대상이 되는 값의 타입을 고려하지 않고 비교를 수행한다는 아주 잘못된 정보로 인해 발생했다.

== 연산자는 === 연산자와 유사한 방식으로 피연산자의 타입을 비교하지만 피연산자의 타입이 다른경우 == 연산자는 비교 이전에 강제로 타입을 맞추는 작업을 수행한다. 두 연산자 모두 타입이 같은 값을 비교한 다는 점에서는 동일하지만 == 연산자는 강제 변환을 먼저 실행해 피연산자의 타입을 맞춘 이후에 작동하기에 **강제 변환 동등 연산자**라고 설명하는게 적합하다.

```jsx
42 == "42"; //true
1 == true; //true
```

두 줄의 피연산자 모두 타입이 다르지만 동등 연산자는 숫자형이 아닌 값을 숫자로 바꾼다음 비교를 하였습니다. 뿐만아니라 <, >, <=, >= 과 같은 연산자들 역시 타입이 다름 경우에는 강제 변환이 일어난다.

비교 연산자는 피연산자가 모두 문자열인 경우를 제외하고는 숫자 타입으로 타입을 변환해 비교를 진행한다. 피연산자 모두가 문자열인 경우에는 사전처럼 알파벳순으로 문자열을 비교한다.

비교 연산자를 사용할 때 타입 면환을 피할 방법은 피연산자의 타입을 일치시키는 것 말고는 없고 개발을 하다 보면 피연산자끼리 타입이 다른 경우를 피하지 못할 가능성도 높기에 비교 연산자의 작동 방식을 제대로 배우고 받아들이는게 현명한 접근이다.

## 2.6 코드 구조화 패턴

JS 생태계 전반에 걸쳐 데이터와 행동 관점에서 코드를 구조화하는 패턴은 크게 클래스와 모듈 두 가지가 있고, 두 패턴은 서로 상호 배타적인 패턴이 아니다. 그렇기 때문에 많은 프로그램이 두 패턴을 모두 사용한다.

### 2.6.1 클래스

클래스는 사용자가 정의한 데이터 ‘타입’으로 데이터와 이 데이터를 조작하는 동작이 들어간다. 그런데 클래스는 사용자 정의 데이터 타입이 어떻게 동작하는지 정의하긴 하지만 구체적인 값은 아니다. 프로그램에서 사용할 수 있는 구체적인 값이 필요하면 new 키워드를 사용해 인스턴스를 만든다.

```jsx
class Page {
  constructor(text) {
    this.text = text;
  }

  print() {
    console.log(this.text);
  }
}

class Notebook {
  constructor() {
    this.page = [];
  }

  addPage(text) {
    var page = new Page(text);
    this.pages.push(page);
  }

  print() {
    for (let page of this.pages) {
      page.print();
    }
  }
}

var mathNotes = new Notebook();
mathNotes.addPage("기초 연산: + = * / ... ");
mathNotes.addPage("삼각법: sin cos tan .... ");

mathNotes.print();
//....
```

Page 클래스에서 문자열 형태의 데이터는 this.text 멤버 변수에 저장되고 print()메서드를 사용하여 콘솔에 데이터를 출력할수 있다.

Notebook 클래스에서는 Page 인스턴스가 요소로 있는 배열을 데이터로 사용하는데 동작을 정의한 메서드는 두가지가 있다. 첫 번째 메서드 addPage()는 Page 인스턴스를 새롭게 만들고 이 인스턴스를 멤버 변수인 배열에 추가하고 또다른 메서드 print()는 Notebook 내 모든 페이지를 출력하는 동작을 한다.

클래스의 동작은 클래스만 가지고 사용할수 없고 인스턴스를 통해서만 호출할 수 있다.

클래스 메커니즘을 사용하면 데이터와 데이터의 동작을 한곳에 묶어 구조화 할수 있다.

**상속**

클래스 지향 설계는 상속과 다향성을 빼놓고 생각할 수 없다.

```jsx
class Publication {
  constructor(title, author, pubDate) {
    this.title = title;
    this.author = author;
    this.pubDate = pubDate;
  }

  print() {
    console.log(`
			제목: ${this.title}
			저자: ${this.author}
			발행일: ${this.pubDate}
		`);
  }
}
```

Publication 클래스에 출판에 필요한 동작이 정의되어있다.

```jsx
class Book extends Publication {
  constructor(bookDetails) {
    super(bookDetails.title, bookDetails.author, bookDetails.publishedOn);
    this.publisher = bookDetails.publisher;
    this.ISBN = bookDetails.ISNB;
  }

  print() {
    super.print();
    console.log(`
			출판사: ${this.publisher}
			ISBN: ${this.ISNB}
		`);
  }
}

class BlogPost extends Publication {
  constructor(title, author, pubDate, URL) {
    super(title, author, pubDate);
    this.URL = IRL;
  }

  print() {
    super.print();
    console.log(`URL: ${this.URL}`);
  }
}
```

Book 과 BlogPost클래스 모두 extends라는 키워드를 사용해 Publication 클래스에서 정의한 동작을 확장해서 사용하고있다.

각 클래스 생성자 내에 있는 super()는 부모 클래스의 생서자를 자식 클래스에서 사용할 수 있도록 동일한 작업을 하는 코드를 다시 작성하지 않아도 출판 타입에 맞게 초기화 할 수 있다.

```jsx
var YDKJSY = new Book({
	title = "You Don't Know JS Yet",
	author: "카일 심슨",
	publishedOn: "2020년 1월",
	publisher: "독립 출판",
	ISBN: "979-8602477249"
});

YDJSY.print();
```

예시에서 부모클래스인 Publication에서 상속받아 재정의한 메서드인 print를 호출할수있는데 자식 클래스 Book과 BlogPost 각각 재정의된 print() 내부에서 super.print()가 호출되면서 부모 클래서에 정의된 메서드 print()를 그대로 상속 받아 사용한다.

이렇게 상속받은 메서드와 새롭게 정의된 메서드의 이름이 동일하고 공존할 수 있는걸 다향성이라고한다.

### 2.6.2 모듈

**모듈의 정의 및 필요성**

모듈은 자바스크립트에서 코드를 구조화하고 관리하기 위해 사용된다. 모듈은 코드의 재사용성을 높이고, 유지 관리를 쉽게 만들며, 글로벌 네임스페이스의 오염을 방지한다. 특히 대형 프로젝트에서 모듈은 필수적이다.

**모듈 패턴**

- **클래식 모듈 패턴:** 클로저를 활용하여 공개 메소드만 외부에 노출시키고 나머지를 숨길 수 있다. 예를 들어, 'Publication', 'Book', 'BlogPost' 등의 객체를 생성하여 공개 API만을 제공한다.
- **공개된 모듈 패턴:** 모듈 패턴을 확장하여 import와 export를 사용하여 코드를 더 깔끔하게 관리할 수 있다.

아래는 자바스크립트에서 모듈을 사용하는 코드의 예시이다:

```jsx
function Publication(title, author, pubDate) {
  var publicAPI = {
    print() {
      console.log(`제목: ${title}\n저자: ${author}\n발행일: ${pubDate}`);
    },
  };
  return publicAPI;
}

function Book(bookDetails) {
  var pub = Publication(
    bookDetails.title,
    bookDetails.author,
    bookDetails.publishedOn
  );
  var publicAPI = {
    print() {
      pub.print();
      console.log(
        `출판사: ${bookDetails.publisher}\nISBN: ${bookDetails.ISBN}`
      );
    },
  };
  return publicAPI;
}

function BlogPost(title, author, pubDate, URL) {
  var pub = Publication(title, author, pubDate);
  var publicAPI = {
    print() {
      pub.print();
      console.log(`URL: ${URL}`);
    },
  };
  return publicAPI;
}
```

이 코드는 모듈 패턴을 사용하여 'Publication', 'Book', 'BlogPost' 클래스를 모듈처럼 활용한다. 각 함수는 객체를 반환하며, 이 객체들은 특정 데이터를 담고 있고, **`print()`** 메서드를 통해 정보를 콘솔에 출력한다.

**모듈화의 장점**

- **재사용성:** 모듈은 코드를 재사용 가능하게 만들어 프로젝트 전반에 걸쳐 일관성을 유지할 수 있도록 도와준다.
- **유지 관리:** 모듈을 사용하면 코드의 유지 관리가 용이해진다. 각 모듈은 독립적이기 때문에 하나의 모듈을 수정하더라도 다른 모듈에 영향을 미치지 않는다.
- **네임스페이스 관리:** 모듈은 전역 네임스페이스를 오염시키지 않고, 필요한 부분만을 노출시켜 프로그램의 안정성을 보장한다.

이처럼 모듈은 코드를 깔끔하고 효과적으로 관리할 수 있게 하는 중요한 도구이다. 모듈을 사용하면 프로젝트의 구조를 명확하게 하고, 각각의 컴포넌트를 쉽게 관리 및 업데이트할 수 있다.
