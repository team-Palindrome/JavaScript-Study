# 4장 더 큰 그림

## 4.1 첫 번째 기둥: 스코프와 클로저

함수나 블록 단위로 변수의 스코프 (유효 범위)를 한정 짓는 것은 모든 프로그래밍 언어의 근본적인 특징이다. 이 특징보다 소프트웨어 작동에 더 큰 영향을 미치는 특징은 아마도 없을 것이다.

스코프는 양동이, 변수는 양동이에 넣을 구슬에 비유할 수 있다. 이 때 언어 고유의 스코프 모델은 구슬과 같은 색을 가진 양동이를 찾도록 도와주는 규칙이다.

스코프 안에는 다른 스코프가 올 수 있다. 이렇게 스코프가 중첩될 때 표현식이나 문은 해당 레벨의 스코프 혹은 더 높거나 바깥 레벨에 있는 변수에만 접근할 수 있고, 낮거나 안쪽 레벨 스코프에 있는 숨겨진 변수에는 접근할 수 없다.

대부분의 프로그래밍 언어는 이런 작동 방식을 취하며 이를 렉시컬 스코프(어휘 스코프) 라고 부른다. 스코프의 기준과 그 경계, 경계 안에서 변수가 어떻게 구성되는지는 프로그래밍을 파싱(또는 컴파일) 할 때 결정된다. 즉, 개발자가 코드를 작성할 때 결정된다. 개발자가 함수나 스코프를 프로그램 내 어디에 배치하느냐에 따라 프로그램 내 해당 코드의 스코프 구조가 결정되는 것이다.

JS는 렉시컬 스코프 모델을 채택하고 있긴 하지만 같은 모델을 사용하는 여타 언어들과는 다른 두 가지 특징을 갖는다. JS만의 독특장 특징 첫 번재는 호이스팅이다. 특정 스코프 내에 선언한 변수가 선언된 위치와 상관없이 해당 스코프 시작 부분에서 선언한 것마냥(끌어올려진 것처럼) 처리되어 호이스팅이란 이름이 붙은 것 이다.

두 번째 특징은 var를 사용해 선언한 변수는 해당 변수를 선언한 블록 위치와 상관없이 함수 기준으로 스코프가 만들어진다는 점이다. 호이스팅과 var로 선언한 변수의 스코프가 함수 스코프라는 특징은 JS가 렉시컬 스코프 모델을 사용하지 않는다는 주장의 근거로 사용될 때가 있는데, 이는 부적합하다. var이 아닌 let이나 const로 선언한 변수는 TDZ라 불리는 특징 때문에 오류가 난 것처럼 특이하게 작동(관찰할 순 있지만 사용은 불가능)하지만 역시 이런 동작 방식 때문에 JS가 렉시컬 스코프 모델을 사용하지 않는다고는 할 수 없다.

클로저는 JS같이 함수를 일급값으로 취급하는 언어에서 렉시컬 스코프 모델을 사용하면 자연스레 나타나는 결과이다. 바깥 스코프에 있는 변수를 참조하는 함수가 있고, 이 함수가 변수를 통해 별개의 스코프에서 실행될 때, 함수는 함수가 정의된 스코프를 기준으로 변수를 참조한다. 이게 바로 클로저이다.

모든 프로그래밍 언어에서, 특히 JS에서 클로저는 모듈 패턴을 비롯한 주요 프로그래밍 패턴을 구현할 수 있게 해준다. JS에서 코드를 체계화할 때 모듈을 활용하면 이점이 매우 많다.

<br>

## 4.2 두 번째 기둥: 프로토 타입

JS를 지탱하는 두 번째 기둥은 프로토타입 시스템이다. JS는 클래스를 통해 사전에 구조를 정의하지 않아도 직접적이고 명시적으로 객체를 만들 수 있는 몇 안되는 언어 중 하나이다.

과거 몇 년간 개발자들은 프로토타입을 사용해 프로토타입 상속이라 부르는 클래스 디자인 패턴을 구현해왔다. 그런데 ES6에서 class 키워드가 등장하면서 JS를 객체 지향/클래스 스타일로 개발하자는 움직임이 심화되었다.

클래스는 프로토타입이 가진 강력한 히믈 기반으로 하는 하나의 패턴에 불과하다. 한편으로는 객체는 객체로서 그대로 두고, 클래스 없이 프로토타입 체인을 통해 객체가 협력하도록 하는 전혀 다른 방식의 접근법도 있다. 이 접근법을 **작동 위임(behavior delegation)** 패턴이라고 한다. 필자는 코드 동작과 데이터를 구조화하는 데 있어서 작동 위임 패턴이 클래스 상속보다 더 강력하다고 생각한다고 한다.

어쨌든 클래스 상속이 개발자들의 거의 모든 관심을 독차지하고 있는 상황이고, 나머지 관심은 '안티 클래스'의 일종인 함수형 프로그래밍이 차지하고 있다.

필자는 "클래스만이 객체를 사용하는 유일한 방법은 아니다" 라는 의견이라고 한다. 클래스도 물론 JS의 본질에 가깝지만 객체 위임이 JS의 본질에 더 가깝다고(다시 말해 JS의 본질을 따른다고) 필자는 이야기 한다.

<br>

## 4.3 세 번재 기둥: 타입과 타입 강제 변환

JS를 지탱하는 세 번째 기둥은 JS 본질에서 가장 간과되는 영역이다.

개발자 상당수는 JS에서 **타입**이 어떻게 작동하는지 잘 모르는 채로 개발하곤 한다. JS 커뮤니티의 관심사는 대부분 타입 기반의 타입스크립트나 플로 같은 도구를 사용하는 **정적 타입**방식 개발로 쏠리고 있는 추세이다.

JS 개발자는 타입에 관해 더 많이 학습하고 JS에서 타입 변환이 어떻게 이뤄지는지 반드시 배워야 한다. 타입 관련 기초 지식이 갖춰진 후에 타입 기반 도구를 사용하면 개발 생상성이 올라갈것 이다.

하지만 필자는 JS 타입 메커니즘의 단점 때문에 해결책을 언어 밖에서 찾을 수 밖에 없다는 결론에 동의할 수 없다고 한다. 꼭 정적 타입이 필요한건 아니라고 이야기 하고 있고, JS의 본질을 따른다면 정적 타입 도구 없이도 목표한 바를 달성할 수 있다고 한다.

어떤 JS 관련 프로그램이나 도구도 JS에서 값의 타입을 다루는 방식과 타입 강제 변환 메커니즘을 응용하지 않았더라면 제 기능을 다하지 못할 것이라고 이야기 한다.

JS에서 어떻게 타입을 관리하는지 깊숙이 이해하지 못한다면 타입스크립트나 플로 같은 정적 타입 도구를 사용해서 문제를 해결하는 방식을 최대로 활용하지 못할 것이라고 이야기 한다.
