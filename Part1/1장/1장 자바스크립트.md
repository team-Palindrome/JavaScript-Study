# 1장 자바스크립트

- **Contents**

# 1.자바스크립트

## 1.2 자바스크립트 이름의 유래

_자바와 자바스크립트의 관계는 햄과 햄스터의 관계와 같습니다. - 제러미 키스,2009_

자바스크립트라는 이름은 사실 마케팅 목적으로 사람들을 속이기 위해 고안된 이름이다.

브렌던 아이크는 처음에는 모카라는 암호명으로 불렀고 그가 재직 중이던 넷스케이프에서는 라이브 스크립트라는 브랜드명을 붙였다. 그후 외부에 공개할 때가 되어서 자바스크립트라는 공식 명칭으로 불리게 되었다.

자바스크립트라는 이름은 이 언어가 자바 개발자들에게 어필하기 위해 만들어졌고, 당시 스크립트라는 단어가 가벼운 프로그램이라는 뜻으로 유행했기 때문이다.

정리하자면 자바스크립트라는 이름은 이미 잘 알려져 있고, 무거운 언어였던 자바 개발자들의 입맛에 맞게 만들었고, 개발자들에게 어필하기 위해 마케팅 목적으로 고안된 이름이다.

자바스크립트와 자바가 별개의 언어라곤 하지만 자바스크립트 코드와 자바 코드가 완전히 다르지 않으며 블록 시작과 끝을 중괄호로 사용하고 문이 끝날때 세미콜론을 사용한다는 점등 표면상 비슷한데 이는 두 언어 모두 C언어(혹은 C++)와 유사한 문법을 기대하는 개발자를 대상으로 만들어졌기 때문이다.

또한 두 언어는 법률적 관점에서 더 강하게 결부된다. 썬 마이크로시스템즈는 넷스케이프를 인수하며 자바스크립트를 비롯한 몇몇 기술을 함께인수했다. 이후 오라클이 썬 마이크로시스템즈를 인수하면서 자바의 소유권을 갖게 되었고, 이를 통해 자바스크립트라는 이름의 소유권도 가지게 되었다.

위와 같은 이유로 일각에서는 자바스크립트라는 명칭 대신 JS라는 이름을 사용하자고 제안한다.

JS라는 약어를 언어 브랜딩에 공식적으로 활용한다는 게 좋지 않은 선택지 같아 보이지만, 이미 매우 흔하게 사용되는 약어다.

오라클이 소유한 상표가 아닌 TC39에서 지정하고 ECMA 표준 기구에 의해 공식화된 명칭으로 JS를 부르면 ECMAScript가 된다. 2016년부터는 ECMAScript에 개정 연도를 붙이기 시작했다.

JS를 JS6나 ES8 같은 이름으로 부르는 건 혼란만 야기하기 때문에, 앞으로는 ES20XX나 JS라는 이름만 사용하자.

## 1.3 명세서

**TC39**는 **JS**를 관리하는 기술 운영 위원회로, **JS**의 공식 명세를 관리한다.

**TC39** 위원은 정기 모임에서 명세 변경 안건을 투표하고, 합의된 변경 사항을 국제 표준화 기구인 **ECMA**에 제출한다. 바로 이 명세서에 JS문법과 작동 방식이 정의된다.

**TC39** 위원회는 약 50~100명으로 구성되는데, 브라우저를 만드는 조직(모질라, 구글, 애플)과, 하드웨어 제조사(삼성) 같이 웹에 투자를 많이 하는 회사 출신이 주를 이룬다. **TC39**는 보통 격월로 회의를 열며 약 3일동안 회의를 진행하는데, 회의에서는 지난 회의 이후 진행된 작업을 검토하고, 이슈를 논의하고, 투표를 진행한다. 회의는 주최 의사를 비친 회원사를 순회하며 열린다.

**TC39**에서 모든 제안은 0부터 4까지 다섯 단계로 아래와 같이 진행된다.

1. **Stage 0 - Strawman (안건 제출 단계)**: 제안의 초기 아이디어를 소개하는 단계로, 어떤 아이디어든 TC39 회의에서 논의될 수 있다. 이 단계의 제안은 공식적인 문서나 후원자가 필요하지 않다.
2. **Stage 1 - Proposal (제안 단계)**: 제안이 공식적으로 인정받아 초기 검토가 시작되는 단계다. 제안자는 제안의 목적, 예상되는 문제점 및 해결책을 자세히 기술해야 하며, 이 단계에서 후원자와 명확한 사용 사례가 필요하다.
3. **Stage 2 - Draft (초안 단계)**: 제안이 초기 형태의 사양으로 발전하는 단계다. 이 단계에서는 사양의 초안, 구문 및 API의 정확한 정의, 구현을 위한 의사 코드 등이 필요하다. 이 단계에서 제안은 테스트와 초기 평가를 받게 된다.
4. **Stage 3 - Candidate (후보 단계)**: 제안이 거의 완성된 형태로, 실제 구현과 피드백을 받는 단계다. 이 단계에서는 최소한 하나의 구현이 필요하며, 완벽한 사양과 폭넓은 피드백이 요구된다. 이 시점에서 제안은 상세한 리뷰와 구현 과정에서 나온 문제를 수정하는 과정을 거친다.
5. **Stage 4 - Finished (완료 단계)**: 제안이 **ECMAScript** 표준의 일부가 되기 위한 최종 단계다. 이 단계에 도달하려면, 두 개 이상의 독립적인 구현이 필요하며, 모든 주요 이슈가 해결되어야 한다. 이 단계의 제안은 다음 버전의 **ECMAScript** 표준에 포함될 준비가 완료된 것으로 간주된다.

새로운 아이디어가 0단계로 올라가는 방법은 간략하게 **TC39** 회원이 아닌 누군가가 소셜 미디어나 블로그 같은 비공식 수단을 통해 아이디어를 ‘제안’하고 **TC39** 위원중 한 명이 해당 아이디어가 가치 있다고 생각해 제안하면 ‘0단계’로 올라간다.

0단계부터 시작한 제안은 4단계까지 올라가는데 짧게는 몇 달, 길게는 몇 년이 걸리고 올라가서야 다음 연도 개정안에 포함될 자격을 갖게 된다.

모든 제안은 **TC39** 공개 깃허브 저장소에서 확인할 수 있다.

**JS**버전에 대해 이야기하자면, **JS**에는 버전이 없다. 여전히 **JS**를 버전으로 구분하고, 이게 공식인 것처럼 이야기하는 분들이 많지만 TC39와 ECMA에 의해 유지되는 공식적인 표준 JS는 하나뿐이다. 2000년대 초반 마이크로소프트가 **JS**를 불완전하게 리버스 엔지니어링해 **JScript**라는 언어를 만들었을 당시에는 여러 버전의 **JS**가 있긴 했지만, 현시대에서는 단 하나뿐이다.

### 1.3.1 JS를 지배하는 웹

JS는 브라우저나 서버 뿐만 아니라 점차 그 영역을 확장하고 있지만 가장 큰 비중을 차지하는 분야는 단연코 웹이다.

대부분 명세서에 정의된 JS와 브라우저 엔진에서 돌아가는 JS는 동일하지만 몇 가지 차이점이 있다.

새로운 동작이 추가되거나 기존 작동 방식을 변경하는 등 명세서가 개정되는데, 기존 브라우저 엔진에서 실행되던 JS의 작동 방식과 다른 경우가 발생하기도 한다. 이런 불일치가 발생하는 이유를 알아둘 필요가 있다.

JS엔진 제조사들은 20년 넘는 긴 세월동안 웹 콘텐츠를 다루는 기능을 구현했는데, 오류없이 웹 콘텐츠를 보여주려다 보니 에지 케이스를 다루는 기능도 자체적으로 추가했다. 이런 상황에서 변경된 명세서 개정안을 반영했을 때 기존에 잘 보이던 콘텐츠가 깨지는 경우 브라우저 제조사들은 명세서 개정안을 반영하지 않겠다는 결정을 내리게 된다.

불일치가 발생하면 TC39 위원회는 종종 기존 결정을 철회하고 명세서를 웹에 맞추는데 배열 메서드 contains()를 추가하려다 includes()로 수정한 사례와 flatten()이 제안되었다가 flat()으로 이름이 바뀐 사례가 유명하다.

때때로 브라우저 기반 JS 엔진이 명세서를 준수할 가능성이 거의 없음에도 명세서를 변경하지 않는 경우가 있는데 이런 문제는 ECAMScript 명세서와 실제 웹에서 돌아가는 JS의 차이가 상세히 기록되어 있는 명세서 페이지 부록 B를 참고해 해결할 수 있다.

해당 부록 B에 적힌 예외들은 브라우저에서만 허용되기 때문에 다른 환경은 명세서를 준수해야 한다.

### 1.3.2 JS지만 JS가 아닌 웹 전용 문법

```jsx
alert("JS야 안녕!");
```

위의 코드에서 사용된 alert는 명세서에는 없지만 모든 웹 환경에서 지원하는 함수다. JS가 실행되는 환경은 전역 스코프에 API를 추가해 자체적으로 사용하는 기능을 제공하는데 **alert()** 함수가 이에 해당한다.

위와 같이 JS처럼 보이지만 **fetch()**, **getCurrentLocation()**, **getUserMedia()** 역시 웹에서만 지원되는 API다.

또한 자주 사용하는 **console.log()** 또한 광범위하게 사용되어 JS처럼 인식되는 대표적인 메소드다.

즉 위의 문법들은 JS에 정의된 문법이 아니지만, JS의 메서드 규칙을 따르고 JS처럼 보이는데 JS라는 생태계에 속하려면 표면상 JS 문법 규칙을 준수해야 한다.

### 1.3.3 모든 코드가 JS인 것은 아닙니다

개발자 도구는 개발자를 위한 도구로, 개발자의 편의성을 가장 우선시해 만들어졌다. 이 도구들이 명세서에 정의된 명세를 정확히 재현하기 위해 만들어진 것은 아니다. 그래서 개발자 도구가 JS의 프로그램 처리 방식을 항상 엄격하게 따르지 않는다는 걸 알아야 한다.

콘솔에 입력한 코드는 JS 엔진이 .js 파일을 다루는 방식과 완전히 동일한 방식으로 처리되지 않는다.

콘솔의 목적은 개발자가 짧은 코드를 입력하고 결과를 즉시 확인하기 위한 것이지, 결과를 무조건 신뢰하진 말고 개발자 도두가 ‘JS에 우호적인’ 별도의 환경이라는 점을 유념해야 한다.

## 1.4 JS의 다양한 얼굴

프로그래밍 분야에서 ‘패러다임’ 이라는 용어는 코드를 어떻게 구조화할지에 대한 접근 방식과 사고방식을 의미하며 익히 알려진 프로그래밍 패러다임으로는 절차적, 객체 지향, 함수형이 있다. 각 패러다임의 특징은 다음과 같다.

- 절차적 프로그래밍은 코드가 톱다운이면서 선형적으로 구조화되는데 이때 프로시저라 불리는 코드 단위에 미리 정해진 일련의 연산을 작성한다.
- 객체 지향 프로그래밍은 클래스 기준으로 코드를 구조화하며, 클래스에는 로직과 데이터가 정의된다.
- 함수형 프로그래밍은 코드를 함수 단위로 구조화하고 이때 함수는 부수 효과가 없는 순수함수이며, 함수 자체가 값으로 취급된다는 특징을 가진다.

몇몇 언어는 특정 패러다임에 꽤 치우쳐져 있는데 예를 들어 C언어는 절차적 프로그래밍 언어의 대표적인 예이고 자바와 C++은 객체 지향 프로그래밍 언어, 함수형에는 하스켈이 있다.

위와 같이 특정 패러다임에 치우쳐진 언어도 있지만 상당수의 언어는 여러 패러다임을 사용해 코드를 구조화할 수 있도록 지원하며 JS 또한 다중 패러다임 언어라 절차적, 객체 지향, 함수형 스타일 코드를 모두 작성할 수 있다.

## 1.5 하위 호환성과 상위 호환성

JS를 지탱하는 기본 원칙 중 하나는 하위 호환성 보장이다.

하위 호환성이란 단 한 번이라도 유효한 JS 문법이라고 인정되면 명세서가 변경되더라도 절대 그 유효성이 깨지지 않는다는 의미다. 하위 호환성 덕분에 1995년에 작성한 코드가 시간이 흘러도 무조건 작동한다는 걸 보장받는다.

하위 호환성과 대응되는 개념으로 상위 호환성이 있다. 새로운 명세서에 추가된 문법으로 코드를 작성했을 때 이전 명세서를 준수하는 구형 JS 엔진에서 문제가 발생하지 않아야 하지만 JS는 상위 호환성을 보장하지는 않는다.

반면에 HTML과 CSS는 상위 호환성을 보장하지만 하위 호환성을 보장하지는 않는다.

1995년에 작성된 HTML, CSS는 오늘날 작동하지 않을 수 있다.

프로그래밍 언어를 설계할 때 상위 호환성을 보장하는 게 바람직해 보이지만 일반적으로 비현실적이다.

마크업이나 스타일링은 본질상 선언적이므로 인식되지 않는 선언은 인식 가능한 선언에 최소한의 영향을 미치면서 건너뛰는 게 훨씬 쉽지만 프로그래밍 언어를 처리하는 엔진이 이해할 수 없는 구문이나 표현식을 선택적으로 건너뛴다면 프로그램에 문제가 생기고 혼란이 발생할 수 있다.

### 1.5.1 간극을 줄이기 위한 노력

JS는 상위 호환성을 보장하지 않기에 이전 엔진에서는 유효한 문법으로 작성한 코드가 동작하지 않을 가능성이 있다. ES2019에서 추가된 기능을 사용해 작성한 프로그램은 2016년 엔진에서 실행하면 프로그램이 실행되지 않을 수 있다.

그렇기 때문에 개발자인 우리는 JS로 개발할 때 이런 간극을 줄이기 위한 각고의 노력이 필요하다.

명세서에 새롭게 추가되었지만 구 엔진과 호환되지 않는 문법은 트랜스파일을 통해 호환성 문제를 해결할 수 있다. 트랜스파일이란 용어는 JS 커뮤니티에서 만든 용어로, 한 형태에서 다른 형태로 소스 코드를 변환해주는 것을 의미하는데 이때 변환 후 산출물은 소스 코드다.

상위 호환성으로 인해 발생하는 문제 대부분은 트랜스파일러를 사용하면 해결된다. 트랜스파일러는 새로운 JS 문법을 이전 문법으로 변경해주며 주로 바벨을 사용한다.

- 바벨(Babel)은 자바스크립트 코드를 변환하는 트랜스파일러로, 최신 자바스크립트(ES6 이상) 문법을 구형 브라우저나 환경에서도 동작할 수 있도록 이전 버전의 자바스크립트(주로 ES5)로 변환해주는 도구다. 이를 통해 개발자들은 최신 기능을 사용하면서도 널리 호환되는 코드를 작성할 수 있게 된다. 바벨은 플러그인 기반으로 동작하며, 다양한 변환 작업을 위해 필요한 플러그인을 추가로 설치해서 사용할 수 있다.

트랜스파일러가 어떻게 작동하는지는 아래 예시를 통해 볼 수 있다.

```jsx
//트랜스 파일 전
if (something) {
  let x = 3;
  console.log(x);
} else {
  let x = 4;
  console.log(x);
}

//트랜스 파일 후
var x$0, x$1;
if (something) {
  let x$0 = 3;
  console.log(x$0);
} else {
  let x$1 = 4;
  console.log(x$1);
}
```

let은 블록 스코프이기에 두 변수는 서로 간섭 받지 않지만 let, const가 정의되지 않았던 버전에 맞춰 트랜스파일할 경우 var로 선언한 변수의 유효범위가 블록 수준이 아니기 때문에 두 개의 별도 변수로 변경된 걸 확인할 수 있다.

이쯤 되면 옛날 문법을 쓰면 될 걸 굳이 최신 문법을 쓰고 트랜스파일러를 써서 코드를 작성해야 하는지 의문이 들 수 있지만 최신 JS를 쓰는 게 코드가 깔끔해지고 의도하는 바를 효과적으로 전달할 수 있기 때문이다.

### 1.5.2 간극을 메우기 위한 방법 찾기

상위 호환성 문제가 새로운 문법이 아닌 API 메서드 때문에 발생했다면 이 메서드가 오래된 환경에도 있었던 것처럼 해주는 방법이 가장 일반적인 해결책이고 이런 패턴을 폴리필이라고 한다.

```jsx
//getSomeRecords()는 원격으로 가져온 데이터를 담은 프라미스를 반환한다.
var pr = getSomeRecords();

//데이터를 가져오는 동안 화면에 스피너를 보여준다.
startSpinner();

pr.then(renderRecoreds) //가져온 데이터를 화면에 표시
  .catch(showError) //데이터를 가져오는데 실패했다면 오류 발생
  .finally(hideSpinner); //성공과 실패 여부와 상관없이 마지막에 스피너를 숨김
```

위 코드에서 finally()메서드를 사용했는데 ES2019를 지원하지 않는 환경에서 실행하면 오류가 발생한다.
ES2019를 지원하지않는 환경에서 finally()를 사용하려면 다음과 같이 폴리필이 필요하다.

```jsx
if(!Promise.prototype.finally){
	Promise.prototype.finally = function f(fn){
		return this.then(
			funtion t(v){
				return Promise.resolve(fn())
					.then(function t() {
						return v;
					});
			},
			function c(e){
				return Promise.reslove(fn())
					.then(function t(){
						throw e;
					});
			}
		);
	};
}
```

트랜스파일이나 폴리필은 오래된 환경이나 애플리케이션, JS 최신 기능 이 둘 사이의 간극을 메꾸는 가교 역할을 한다.

## 1.6 인터프리터 이해하기

JS가 인터프리터 언어인지 컴파일러 언어인지에 대한 논쟁은 오랫동안 이어졌고, 이에 대한 중론은 '스크립트 언어다'지만 실상은 좀 더 복잡하다.

인터프리터 언어와 스크립트 언어는 컴파일 언어에 비해 열악하다는 평가를 받아왔는데, 성능 최적화가 잘 안 된다는 인식과 더불어 일부 스크립트 언어에서 좀 더 성숙한 방식인 정적 타입 대신 동적 타입을 사용하는 등의 이유 때문이다.

스크립트 언어나 인터프리터 언어는 대체로 위에서 아래로 한 줄씩 코드가 실행되는 방식으로 만들어진다.

인터프리터나 스크립트 언어로 작성한 프로그램의 다섯 번째 줄에 오류가 있다면 네 번째 줄이 실행될 때까지는 오류를 발견하지 못한다.

한편 이와 달리 프로그램이 실행되기 전에 파싱이라는 사전 단계를 거쳐 사전에 오류를 차단하는 언어도 있다. 굳이 실행까지 하지 않아도 파싱이 되지 않아 프로그램을 실행할 수 없기 때문에 실행 전에 오류가 포함된 코드 조각이 어디 있는지 알 수 있고 구문 오류를 차단하기 좋다.

모든 컴파일 언어는 파싱을 거치고, 파싱이 끝나면 언제가 컴파일이 진행될 거라고 예상할 수 있다.

파싱이 완전히 끝난 다음에는 파싱 결과인 추상 구문 트리를 컴퓨터가 실행할 수 있는 형태로 변경하는 작업이 이어지고 실행 가능한 코드를 생성하는 작업이 수행된다. 이러한 이유로 파싱을 거치는 언어는 컴파일 언어라고 통용된다.

JS로 작성한 소스 코드는 실행 전 파싱을 거친다. 중복된 매개변수명과 같이 정적으로 탐지가 가능한 오류를 초기 오류라고 부르며, 가능하면 프로그램 실행 전에 초기 오류를 찾아낼 수 있어야 한다고 언급하는데 파싱이 없다면 이런 오류를 사전에 탐지할 수 없다.

컴파일 단계에서는 JS 가상 머신에 전달할 이진 바이트 코드가 생성된다. 혹자는 가상 머신의 역할이 전달받은 코드를 해석하는 것이라고 이야기하고 이 때문에 인터프리터 언어라고 해석한다.

또한 이때 JS 엔진은 생성된 코드를 다양한 방법으로 실행 전에 그때그때 처리 및 최적화를 진행한다.

이런 JS 엔진 작동 방식으로 인해 관점에 따라 JS를 컴파일 언어 혹은 인터프리터 언어라고 할 수 있다.

위의 내용을 정리하면 아래와 같은 절차를 거치는지 알 수 있다.

1. 개발자의 손을 떠난 코드는 바벨이 트랜스파일하고, 이후 웹팩을 비롯한 번들러를 거쳐 번들링되고, 그 결과가 JS 엔진에 전달된다.
2. JS 엔진은 전달받은 코드를 파싱해 추상 구문 트리로 바꾼다.
3. 이어서 엔진은 추상 구문 트리를 이진 바이트 코드로 바꾸고, 이 과정에서 JIT 컴파일러가 작동하며 최적화가 함께 진행된다.
4. 마지막으로 JS 가상 머신이 프로그램을 실행한다.

### 1.6.1 웹어셈블리

JS 엔진은 원래 자바스크립트 코드를 실행하기 위해 구축되었으며, 코드가 표준 JS 문법을 따르면 이를 해석하고 실행하는 역할을 한다. 2013년 Mozilla Foundation이 파이어폭스 브라우저에서 새로운 JS 엔진인 ASM.js를 개발하면서, 이 엔진은 특히 JS의 특정 부분집합을 최적화하여, C와 유사한 성능을 내도록 설계되었다. 이러한 최적화는 JS가 원래 가진 인터프리터 언어의 한계를 넘어서게 해, 성능이 향상된 실행 가능한 코드를 제공한다.

WebAssembly (Wasm)는 이러한 발전을 한층 더 발전시켜, 브라우저에서 네이티브에 가까운 성능을 구현할 수 있도록 설계된 새로운 포맷이다. Wasm은 JS가 아니며, JS 엔진에서 처리되는 것처럼 보일지라도 사실은 JS의 복잡한 계산을 빠르게 처리할 수 있도록 돕는 별도의 바이너리 포맷이다. Wasm은 코드를 파싱하고 추상 구문 트리로 변환한 후, 이를 이진 바이트 코드로 컴파일하여 JS 엔진에 전달한다.

이 과정에서 Wasm은 JS와 독립적으로 작동하며, TC39 표준화 과정을 거치지 않는다. 하지만, Wasm이 JS와 완전히 독립적이라기 보다는 JS와 함께 작동하며 서로를 보완하는 관계로, JS를 사용하여 웹에서 고성능이 필요한 작업을 수행할 때 Wasm이 큰 역할을 한다.

따라서, JS와 Wasm은 각각의 역할과 특성을 갖고 협력하여, 웹 애플리케이션의 성능과 기능을 극대화하는 데 기여한다. 이러한 협력을 통해 브라우저에서의 더 복잡하고 성능이 중요한 애플리케이션을 가능하게 하며, 두 기술의 장점을 최대로 활용한다.

## 1.7 엄격 모드

2009년 ES5에 새로운 메커니즘인 엄격 모드가 추가되고 선택 사항으로 엄격 모드를 사용할 수 있게 되면서 더 나은 JS 프로그램을 만들기 위한 장치가 마련됐다.

엄격 모드를 사용하면 손실보다 이득이 크지만 오래된 습관은 사라지기 어렵고 레거시라 부르는 기존의 코드에 기반한 관성은 바꾸기가 어렵다. 이런 이유로 엄격 모드는 등장한지 10년이 지났지만 여전히 기본이 아닌 선택 사항이다.

엄격 모드는 JS 엔진이 코드를 최적화하고 효율적으로 실행할 수 있게 해주는 최고의 안내 가이드 역할을 하는 모드이다. 린터와 같은 도구를 사용해 엄격 모드로 작업한다면 비엄격 모드에서 발생할 수 있는 실수와 문제를 미연에 방지할 수 있다.

파일 대상으로 적용되는 엄격모드는 전처리 구문 “use strict”;가 있는경우 활성화 된다.

```jsx
//전처리 구문 use strict 앞에는 공백이나 주석만 올 수 있다.
"use strict";
//use strict 때문에 나머지 코드는 엄격 모드로 작동한다.
```

또한 엄격 모드는 함수 단위로 적용할 수 있는데 함수에도 역시 동일한 규칙이 적용 된다.

```jsx
funciton someOperations() {
	//공백이나 주석만 올수있다.
	"use strict";
	//나머지 코드는 이제 엄격 모드로 동작한다.
}
```

여기서 알아야할 부분은 파일 단위 엄격 모드가 적용 되면 함수에는 엄격 모드 전처리 구문을 사용할 수 없다는 점이다. 그렇기 때문에파일에 엄격 모드를 적용할지 함수에 엄격모드를 적용해야할지 하나를 선택해야한다.

함수 단위 엄격 모드는 비엄격 모드에서 작성했던 기존 프로그램에 점진적으로 엄격 모드를 적용 해야 할 때만 사용하는게 좋다.

이런 경우가 아니라면 파일이나 프로그램 전체를 대상으로 한 번에 엄격 모드를 적용하는 게 더 낫다.
