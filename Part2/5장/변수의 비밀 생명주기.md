# 변수의 비밀 생명주기

## 5.1 전역 스코프를 배워야 하는 이유

변수는 자신이 속한 스코프 안에서 언제부터 사용할 수 있게 될까요? 변수가 선언 혹은 생성된 후라고 답하는 분들이 있을 수 있습니다. 하지만 정확히는 아닙니다.

예시를 살펴보겠습니다.

```js
gretting();
// 안녕하오!

function greeting() {
  console.log("안녕하오!");
}
```

예시는 문제없이 잘 동작합니다. 비슷한 코드를 보거나 직접 써본 경험이 있을 수도 있을 수 있습니다. 그런데 이 코드가 어떻게, 왜 작동하는지 생각해본적이 있나요? `greeting()` 이라는 함수 선언은 아래 줄에 있는데, 어떻게 첫 번째 줄에서 식별자 `greeting()`에 접근할 수 있었을까요?

모든 식별자는 컴파일 타임 때 각자의 스코프에 등록된다는 걸 배웠습니다. 그리고 모든 식별자는 자신이 속한 스코프가 생성될 때 해당 스코프의 시작 부분에서 생성된다는 것 역시 배웠습니다.

이렇게 선언은 스코프 아래에 있더라도 스코프 시작 부분에서 변수의 가시성(visibility)이 확보되는 것을 _**호이스팅**_(hoisting)이라고 합니다.

그런데 호이스팅만으로는 의문점을 완전히 해결할 수 없습니다. 스코프 시작 부분에서 식별자 `greeting()`을 호출할 수 있는지는 아직 다루지 않았기 때문입니다.

스코프 내 코드가 실행되기 시작하는 순간, 변수 **greeting**에 어떻게 값(함수 참조)이 할당되는 이유는 함수 선언문의 고유한 특성인 함수 호이스팅 때문입니다. <br>함수 선언문으로 함수를 선언하면 함수 이름에 해당하는 식별자가 스코프 최상단에 등록되고 함수 참조로 그 값이 자동으로 초기화됩니다. 함수 선언문은 이렇듯 함수 호이스팅 때문에 스코프 내 어디서든 호출할 수 있습니다.

참고로 함수 호이스팅과 var를 사용해 선언한 변수의 호이스팅 모두에서 이름 식별자가 블록스코프가 아닌 가장 가까운 함수 스코프에 등록됩니다(가장 가까운 함수 스코프가 없으면 전역 스코프에 등록됩니다).

> 🗒️ Note<br><br>
> let과 const로 변수를 선언해도 당연히 호이스팅이 일어납니다. 하지만 let과 const로 선언한 변수는 var로 선언한 변수와 함수 선언문과 다르게 식별자가 함수 스코프가 아닌 블록 스코프에 등록됩니다.

<br>

### 5.1.1 선언문과 표현식에서의 호이스팅 차이

---

함수 호이스팅은 일반적인 함수 선언문에만 적용되고 함수 표현식에는 적용되지 않습니다. 아래의 예시를 보겠습니다.

```js
greeting();
// TypeError

var greeting = function greeting() {
  console.log("안녕하시오!");
};
```

첫 번째 줄 `greeting();`에서 바로 오류가 발생합니다.<br>
TypeError는 허용되지 않은 값을 가지고 무언가를 하려고 할 때 발생하는 오류입니다. 예시를 실행하는 호스트 환경에 따라 오류 메시지가 `'undefined' is not a function.` 이거나 `'greeting' is not a function.` 일 수도 있습니다.

이상한 점은 ReferenceError가 아니라는 것입니다. 스코프 내 greeting 이라는 식별자를 찾지 못했다는 걸 나타내기 위해 ReferenceError가 발생했어야 하는데 그렇지 않고 JS 엔진은 greeting은 찾았지만, 그 순간에 greeting에 함수 참조가 없다고 이야기합니다.<br>호출 가능한 것은 함수뿐인데 함수가 아닌 값을 호출하려 해서 오류가 발생한 것입니다.

식별자 greeting에 함수 참조가 할당된 게 아니라면 그럼 greeting에는 뭐가 있는 걸까요?

var로 선언한 변수는 호이스팅도 되고 여기에 더해 스코프(가장 가까운 함수 스코프 혹은 전역 스코프)가 시작될 때 undefined로 자동 초기화 됩니다. 초기화가 된 이후에는 스코프 전체에서 이 변수를 사용할 수 있습니다(할당, 참조 등).

이런 이유 때문에 네 번째 줄에 있는 함수 참조 할당이 실행되기 전까지, 첫 번째 줄에 있는 greeting은 기본값인 undefined로 남아 있는 겁니다.

선언문과 표현식에서 주의해야 할 차이점을 정리하면 다음과 같습니다.<br>
함수 선언문은 호이스팅되고 해당 함숫값으로 초기화됩니다(이를 함수 호이스팅이라고 함). 반면 var로 선언한 변수는 호이스팅되긴 하지만 undefined로 초기화됩니다. 그리고 함수 표현식에서 실제 할당은 런타임에 해당 코드가 실행되기 전까지는 일어나지 않습니다.

선언문과 표현식 모두에서 이름 식별자는 호이스팅된다는 공통점이 있긴 합니다. 하지만 초기화 시(스코프가 시작될 때) 함수 선언문이 아닌 경우에는 함수 참조 관련 작업이 처리되지 않습니다.

<br>

### 5.1.2 변수 호이스팅

---

변수 호이스팅과 관련된 예시를 하나 더 살펴보겠습니다.

```js
greeting = "안녕하시오!";
console.log(greeting);
// 안녕하시오!

var greeting = "안녕하오!";
```

네 번째 줄에서 greeting을 선언했음에도 불구하고, 첫 번째 줄에서부터 greeting에 값을 할당할 수 있습니다.

이유는 다음과 같습니다.

- 식별자가 호이스팅됨
- 스코프 최상단에서 식별자가 undefined로 자동 초기화됨

<br>

## 5.2 호이스팅: 비유일 뿐입니다

호이스팅은 자바스크립트 엔진이 실행되는 과정 중의 일부 단계가 아닌 프로그램이 실행되기 전 JS가 수행하는 여러 행동을 시각화하는 도구라는 걸 인지하고 넘어가겠습니다.

사람들은 무거운 물건을 위로 들어 올리는 리프팅(lifting)처럼 호이스팅을 거치면 모든 식별자가 스코프 맨 위쪽으로 올라간다고 생각합니다. 그래서 앞선 예시를 JS 엔진에게 전달하면 JS 엔진이 다음처럼 코드를 재작성해서 실행할 거라 주장합니다.

```js
var greeting; // 호이스팅된 선언
greeting = "안녕하오!"; // 원래 코드의 첫 번째 줄
console.log(greeting); // 안녕하오!
greeting = "잘 지내오?"; // 'var'가 사라졌습니다!
```

이런 비유(리프팅)를 적용하면 호이스팅을 거친 코드는 JS엔진에 의해 전처리되고, 그 과정에서 모든 선언이 재정렬을 거쳐 실행 전에 해당 스코프의 최상단으로 이동하게 됩니다. 물론 이런 비유는 함수 선언때문에도 적용됩니다.

```js
studentName = "서하";
greeting();
// 서하 님, 안녕하세요!

function greeting() {
  console.log(`${studentName} 님), 안녕하세요!`);
}

var studentName;
```

리프팅에 비유한 호이스팅에서는 함수 선언문 모두를 먼저 호이스팅하고 그 다음 변수를 호이스팅한다는 규칙이 있습니다. 그러므로 앞선 예시는 재배열을 통해 다음과 같이 변한다고 생각할 수 있습니다.

```js
function greeting() {
  console.log(`${studentName} 님, 안녕하세요!`);
}

var studentName;

studentName = "서하!";
greeting();
// 서하 님, 안녕하세요!
```

이렇게 비유를 사용해 호이스팅을 이해하면 코드를 쉽게 이해할 수 있습니다. 스코프 깊숙이 묻힌 선언을 찾아내 코드를 맨 위로 이동(호이스팅) 시키는 '마법 같은 선행 처리 과정'을 적용하면 우리는 코드를 그냥 위에서 아래로 읽으면 됩니다. <br>JS 엔진도 그냥 위에서부터 아래로, 단일 패스(single pass)로 프로그램을 실행한다고 생각하면 됩니다.

그런데 호이스팅을 코드 재정렬 매커니즘이라고 생각하는게 이해에는 도움을 주지만 정확하진 않습니다. JS 엔진은 실제 코드를 재정렬하지 않습니다. JS 엔진은 마법처럼 앞을 내다보고 선언문을 찾지 못합니다. 프로그램의 모든 스코프 경계와 선언문을 정확히 찾을 수 있는 유일한 방법은 코드를 파싱하는 것뿐입니다.

파싱 없이 프로그램을 실행할 방법은 그 어디에도 없습니다.

> 이 책에서는 호이스팅을 런타임에 일어나는 동작이 아닌 컴파일 타임에 일어나는 작업의 일부로 바라봐야 한다고 주장합니다.

<br>

## 5.3 중복선언 처리하기

동일한 스코프에서 변수가 두 번 이상 선언되면 어떻게 될까요? 앞선 예시와 이어지는 코드를 살펴봅시다.

```js
var studentName = "성한";
console.log(studentName);
// 성한

var studentName;
console.log(studentName); // ???
```

두 번째 var studentName 에서 변수가 다시 선언, 리셋되면서 undefined가 출력된다고 예상하는 분들이 많을 겁니다.

그런데 동일한 스코프에서 변수가 '재선언(re-declaration)'되는 경우가 있을까요? **아닙니다.**

호이스팅에 관한 기존 비유를 적용해 재배열한 코드를 살펴보겠습니다.

```js
var studentName;
var studentName; // 아무 의미가 없는 작업입니다.

studentName = "성한";
console.log(studentName);
// 성한

console.log(studentName);
// 성한
```

호이스팅은 스코프의 시작 부분에 변수를 등록하는 방식이므로 두 번째 줄(스코프 중간 부분)에 있는 var studentName; 은 아무런 역할을 하지 못합니다. 스코프 내에서 이미 선언된 변수를 중간 부분에서 다시 선언한다고 해서 실제로 어떤 작업이 수행되지 않습니다.

<br>

> ✅ TIP <br><br>
> 컴파일러는 두 번째 var로 선언한 구문을 찾아내고, 스코프 매니저에게 studentName 식별자를 본 적이 있는지 물어봅니다. 이미 봤다는 대답을 들은 경우에는 컴파일러가 더 이상 할 수 있는 일이 없습니다.

<br>

중복 변수 선언에 관한 예시에서 대부분의 사람들이 var studentName; 이 var studentName = undefined; 과 같다고 생각하는데 그렇지 않다는 점도 짚고 넘어가야 할 점입니다. 앞선 예시를 조금 변형해 실제 이 둘이 다르다는 것을 증명해봅시다.

```js
var studentName = "성한";
console.log(studentName); // 성한

var studentName;
console.log(studentName); // 성한 <- 여전히 성한입니다.

// 명시적으로 초기화를 진행합니다.
var studentName = undefined;
console.log(studentName); // undefined 입니다.
```

명시적으로 = undefined 으로 초기화한 경우와 이를 생략했을 때 결과가 어떻게 다른지 봤습니다.

지금까지 살펴본 것과 같이 스코프에서 동일한 식별자를 사용해 var로 새로운 변수를 선언하는 것은 아무런 역할을 하지 않습니다. 그럼 함수는 어떨까요?

```js
var greeting;

function greeting() {
  console.log("안녕하세요!");
}

// 의미 없는 작업이 됩니다.
var greeting;

typeof greeting; // "function"

var greeting = "안녕하세요!";

typeof greeting; // "string"
```

첫 줄은 greeting 식별자를 스코프에 등록하는데, var를 사용했기 때문에 undefined로 자동 초기화 됩니다. greeting 함수 선언에서는 greeting을 다시 스코프에 등록하지는 않지만 함수 호이스팅이 일어나고, 함수 호이스팅은 변수 호이스팅보다 우선순위가 높기 때문에 greeting을 함수 참조로 초기화시킵니다.

두 번째 var greeting은 greeting이 이미 식별자로 등록되어 있고 함수 호이스팅이 더 우선순위가 높기 때문에 아무 작업도 수행하지 않습니다.

마지막 `var greeting = "안녕하세요!";` 에서는 greeting 변수에 "안녕하세요!" 라는 문자열을 할당합니다. 여기서 var는 아무런 역할을 하지 않습니다.

그러하면 동일 스코프에서 let이나 const로 중복 선언을 하는 경우는 어떨까요?

```js
let studentName = "성한";

console.log(studentName);

let studentName = "기원";
```

이 프로그램은 실행되지 않고 즉시 SyntaxError가 발생합니다. JS 환경에 따라 다르겠지만, 'studentName은 이미 선언되었다'고 오류 메시지가 표시됩니다. 즉, let 이나 const를 사용한 '재선언'은 명시적으로 허용되지 않습니다.

이 오류는 같은 이름을 가진 변수를 둘 다 let 으로 선언하는 경우에만 발생하지 않습니다. 두 선언 중 하나가 let이고 나머지 선언이 var인 경우에는 오류가 발생합니다.
첫 번째 예시를 보겠습니다.

```js
var studentName = "성한";

let studentName = "기원";
```

두 번째 예시입니다. 여기에서도 SyntaxError가 발생합니다.

```js
let studentName = "성한";

var studentName = "기원";
```

두 경우 모두 두 번째 선언에서 SyntaxError가 발생합니다. 즉, 변수를 재선언하는 유일한 방법은 선언에 모두 var를 사용하는 것뿐입니다.

그럼 왜 let과 var를 섞어서 재선언하면 안 되는 걸까요? var를 사용한 재선언은 이전부터 지금까지 허용되어왔기 때문에 기술적인 문제가 있는 건 아닙니다. let도 기술적으로는 재선언이 가능합니다.

사실 이건 기술보다는 사회 공학 문제에 가깝습니다. TC39 위원을 비롯한 업계 관계자는 변수를 재선언하는 습관을 버그를 일으키는 나쁜 습관으로 여깁니다. 그래서 ES6에서 let을 추가 할 때 오류와 함께 재선언을 방지하기로 했습니다.

> 🗒️ NOTE <br><br>
> let, const로 선언한 변수의 재선언 방지는 기술적 주장이 아닌 스타일에 관한 의견입니다. 다만 많은 개발자들이 이 의견에 동의하기 때문에 TC39에서 변수 재선언 시 오류를 발생시키도록 했을 겁니다. 물론 이런 현재 상황에 이견이 있을 수 있습니다. let, const 에서도 var의 선례를 일관되게 따르고 린터 같은 옵트인(opt-in) 도구를 사용해 개발자들의 의견을 반영하는게 합리적인 주장일 수도 있습니다.

컴파일러가 스코프 매니저에 선언에 대한 정보를 요청할 때, 이미 해당 식별자가 선언되어 있고 그중 하나 이상이 let으로 선언된 경우 오류가 발생합니다. 이 오류는 개발자에게 '무심코 선언을 반복하는 것을 그만두세요!'라고 경고하는 거라 생각하면 됩니다.

<br>

### 5.3.1 const 재선언

---

const 키워드는 let 보다 제약조건이 더 많습니다. const 역시 let과 마찬가지로 동일한 스코프 내에 동일한 식별자를 사용할 수 없습니다. 그런데 let은 문체상의 이유로 '재선언'을 허용하지 않지만, const가 '재선언'을 허용하지 않는 데에는 기술적 이유가 있습니다.

const 키워드를 사용하려면 기본적으로 변수를 초기화해야 하므로 const로 변수를 초기화할 때 할당을 생략하면 SyntaxError가 발생합니다.

```js
const empty; // SyntaxError
```

그리고 다음 예시에서 확인할 수 있듯이 const로 변수를 선언하면 재할당이 불가능한 변수가 생성됩니다.

```js
const studentName = "민지";
console.log(studentName);
// 민지

studentName = "성준"; // TypeError
```

변수 studentName 은 const로 선언했으므로 재할당이 불가능합니다.

> ⚠️ WARNING <br><br>
> studentName에 재할당할 때 발생하는 오류는 SyntaxErrorr가 아닌 TypeError입니다. 이 미묘한 차이가 사실 매우 중요하지만, 안타깝게도 우리는 이 차이를 너무 쉽게 간과하곤 합니다. SyntaxError는 프로그램이 실행되기 전에 발생하는 오류로, 프로그램을 실행조차 하지 못하게 만듭니다. 반면 TypeError는 프로그램 실행 중에 발생하는 오류로, 프로그램이 이미 실행 중인 상태에서 오류가 발생합니다.

<br>

const로 선언된 변수를 다시 선언하는 것은 해당 변수를 재할당하는 것과 같습니다. 그런데 const 선언은 재할당할 수 없으며 항상 할당이 필요합니다. 따라서 이런 기술적인 이유로 const를 사용한 재선언은 허용되지 않습니다.

<br>

```js
const studentName = "성준";

// 분명히 오류가 발생할 겁니다.
const studentName = "민지";
```

const 재선언은 기술적인 이유로 허용되지 않아야 하므로 TC39는 일관성 유지를 위해 let 재선언도 허용하지 않는 게 좋다고 결정했을 겁니다.

<br>

### 5.3.2 반복문

---

JS에서는 동일한 스코프 내에서 변수를 다시 선언하는 것을 추천하지 않는다는 점을 분명히 했습니다. 그런데 이 논의는 반복문 안에서 선언을 반복적으로 실행하는게 무엇을 의미하는지 생각해보기 전에는 단순한 훈계처럼 보일 여지가 있습니다.

```js
var keepGoing = true;

while (keepGoing) {
  let value = Math.random();

  if (value > 0.5) {
    keepGoing = false;
  }
}
```

이렇게 프로그램을 작성하면 value가 반복적으로 재선언될까요? **그렇지 않습니다.**

스코프 규칙(let 으로 생성한 변수 재선언 포함)은 각 스코프 인스턴스마다 적용됩니다. 이는 실행 중에 각 스코프가 시작될 때마다 모든 것이 초기화된다는 말입니다.

반복문에서는 새로운 반복이 시작될 때마다 자체적인 새 스코프가 생성됩니다. 이때 value는 새 스코프 내에서 단 한 번만 선언됩니다. 따라서 '재선언' 시도 자체가 없었으므로 예시에서는 오류가 발생하지 않습니다. 그럼 이번에 잠깐 let 선언을 var로 바꾸면 어떤 일이 발생할지 살펴보고 넘어가겠습니다.

```js
var keepGoing = true;

while (keepGoing) {
  var value = Math.random();

  if (value > 0.5) {
    keepGoing = false;
  }
}
```

여기서는 var를 사용했는데, value가 재선언될까요? 그렇지 않습니다. var는 블록 스코프 선언으로 취급되지 않고 전역 스코프에 연결됩니다. 따라서 여기서 반복문 안의 var 선언은 무시되고 value는 keepGoing과 동일한 전역 스코프에 존재하게 됩니다.

변수 선언에 사용되는 var, let, const 키워드는 코드가 실행되기 전에 컴파일러에 의해 처리되기 때문에 사실상 지워진 채로 실행된다고 생각하면 조금 더 쉽게 이 상황을 이해할 수 있습니다.

선언 키워드를 머리속에서 지운 다음, 코드를 해석해보면 변수의 (재)선언이 언제, 어떻게 발생하는지를 이해하는 데 도움이 됩니다.

이번에는 for 반복문에서 재선언 여부를 알아보겠습니다.

```js
for (let i = 0; i < 3; i++) {
  let value = i * 10;
  console.log(`${i}: ${value}`);
}

// 0: 0
// 1: 10
// 2: 20
```

콘솔 결과를 통해 루프가 반복되어도 value는 새로 선언되지 않고 스코프 인스턴스 내에서 단 한 번만 선언된다는 점을 명확히 확인할 수 있습니다. 그렇다면 i는 어떨까요? 재선언되는 걸까요?

먼저, i가 어떤 스코프에 속해 있는지 생각해봅니다. 가장 바깥 스코프(이 경우에는 전역 스코프)에 속한 것 같지만, 사실은 그렇지 않습니다. value의 스코프와 마찬가지로 i도 for 반복문 스코프 안에 있습니다.

for 반복문에서 변수 i와 value는 **각 스코프 인스턴스마다** 정확히 한 번만 선언된다는 점이 명확해집니다. 재선언이 일어나지 않습니다.

그럼 다른 형태의 for 반복문을 보겠습니다.

```js
for (let index in students) {
  // for ...in 반복문 안에서 변수를 선언해도 괜찮습니다.
}

for (let student of students) {
  // 역시 마찬가지 입니다.
}
```

for ...in과 for ...of 반복문에서도 마찬가지입니다. 선언한 변수는 반복문 본문 스코프에 속한 변수로 취급되므로 반복이 일어날 때마다(인스턴스 스코프가 생성되고) 해당 스코프 내에서 처리됩니다. 그리고 역시 재선언은 일어나지 않습니다.

이번에는 const가 반복문 구조에 어떤 영향을 미치는지 보겠습니다.

```js
var keepGoing = true;

while (keepGoing) {
  // 빛나는 상수가 여기 있습니다!
  const value = Math.random();

  if (value > 0.5) {
    keepGoing = false;
  }
}
```

앞서 let을 사용해 작성했던 while 반복문 예시와 마찬가지로 const는 반복문이 이터레이션될 때마다 정확히 한 번 실행되기 때문에 재선언 문제에서 안전합니다. 그런데 for 반복문에서는 문제가 좀 복잡해집니다.

for ...in과 for ...of는 const와 함께 사용해도 괜찮습니다.

```js
for (const index in students) {
  // 괜찮습니다.
}

for (const index of students) {
  // 이 역시 괜찮습니다.
}
```

하지만 일반적인 for 반복문에서는 const를 사용하는게 안전하지 않습니다.

```js
for (const i = 0; i < 3; i++) {
  // 첫 번째 이터레이션 이후 타입 오류가 발생하며 실패합니다.
}
```

무슨 일이 벌어진 걸까요? 일반 for 반복문에서도 let을 사용했었고, 각 반복문의 이터레이션 스코프마다 새로운 i가 생성된다고 했기 때문에 재선언 문제는 아닙니다.

아시다시피 const 변수는 재할당이 허용되지 않습니다. 재선언이 아닌 **재할당**이 일어나서 오류가 발생한 것입니다.

일반 for 문에서 const를 사용하면 재할당이 필요하기 때문에 사용하면 안 됩니다.

<br>

## 5.4 초기화되지 않은 변수와 TDZ

var로 선언한 변수는 해당 스코프의 맨 위로 올라가는데, undefined으로 자동 초기화되므로 스코프 전체에서 사용할 수 있습니다.

그런데 let과 const로 선언한 변수는 작동 방식이 조금 다릅니다. 다음 코드를 살펴보겠습니다.

```js
console.log(studentName);
// ReferenceError

let studentName = "민지";
```

프로그램을 실행하면 첫 번째 줄에서 ReferenceError가 발생합니다. 간혹 JS 환경에 따라 'Cannot access studentName before initialization(초기화 하기 전에는 studentName에 접근할 수 없습니다)' 라는 오류 메시지가 표시될 수 있습니다.

<br>

> 🗒️ NOTE <br><br>
> 예전에는 이보다 훨씬 더 모호하거나 오해의 소지가 있는 오류 메시지가 표시되곤 했습니다. 다행히 커뮤니티 구성원들이 JS 엔진에서 출력되는 오류 메시지를 개선하도록 압력을 가했고, 더 정확한 오류 메시지를 표시하도록 하는 데 성공했습니다.

첫 번째 줄에 studentName이 있지만, 초기화되지 않아 사용할 수 없다는 걸 잘 나타냅니다.

<br>

```js
studentName = "성준"; // 초기화를 시도
// ReferenceError

console.log(studentName);

let studentName;
```

위의 경우에는 첫 번째 줄에서 초기화되지 않은 변수 studentName에 할당(일명 초기화)를 시도했지만 여전히 ReferenceError가 발생합니다.

여기서 우리가 생각해봐야 할 진짜 문제는 초기화되지 않은 변수를 어떻게 초기화할 수 있는지 입니다. let/const로 변수를 선언할 때는 선언문에 할당을 덧붙이는 것만이 유일한 방법입니다. 할당만으로는 부족합니다.

<br>

```js
let studentName = "민지";
console.log(studentName); // 민지
```

이번에는 할당과 let 선언문을 조합해 studentName을 초기화했습니다
(여기서는 undefined가 아니라 "성준"으로 초기화).

<br>

```js
// ...

let studentName;
// 또는 let studentName = undefined;
// ...

studentName = "민지";

console.log(studentName);
// 민지
```

<br>
<br>

지금까지 컴파일러는 var/let/const 선언자를 제거하고 각 스코프 최상단에 해당 식별자를 등록하도록 명령한다는 점을 몇 번이나 강조한 바 있습니다.

이 내용을 조금 더 자세히 분석하면, 컴파일러는 프로그램 중간, studentName이 선언된 지점에서 해당 선언을 자동으로 초기화하는 명령도 내립니다. 그렇기 때문에 우리는 이 초기화가 발생하기 전까지는 변수를 사용할 수 없습니다. const로 선언한 변수도 예외는 없습니다.

스코프에 진입한 후, 변수 자동 초기화가 일어나기까지의 시간을 지칭하기 위해 TC39 위원회는 TDZ(temporal dead zone)라는 새로운 용어를 만들었습니다.

**TDZ란 변수는 존재하지만 초기화되지 않아 어떤 방식으로도 해당 변수에 접근할 수 없는 시간대를 의미합니다.** 변수의 초기화는 컴파일러가 원래 선언 지점에 남긴 명령을 실행할 때만 발생합니다. 초기화가 이뤄진 이후에 TDZ는 종료되고, 스코프 내에서 변수를 자유롭게 사용할 수 있게 됩니다.

엄밀히 말하자면 var에도 TDZ가 있지만 길이가 0이므로 프로그램 내에서 var로 선언한 변수는 TDZ를 관찰할 수 없습니다. let과 const에서만 TDZ를 관찰할 수 있습니다.

TDZ는 위치(zone)라기보다는 시간대라고 해석하는게 낫습니다. 코드를 살펴보겠습니다.

```js
askQuestion();
// ReferenceError

let studentName = "성준";

function askQuestion() {
  console.log(`${studentName} 님, 질문해도 될까요?`);
}
```

위치상으로는 학생 이름을 참조하는 console.log() 가 let studentName 선언 뒤에 오지만, 타이밍상으로는 studentName이 아직 TDZ에 있는 동안 let 문을 만나기 전에 askQuestion() 함수가 호출되었기 때문에 오류가 발생합니다.

변수 선언과 초기화에 대한 흔한 오해 중 하나는 TDZ 때문에 const와 let은 호이스팅되지 않는다는 점입니다. 하지만 const와 let도 호이스팅 됩니다.

let/const 선언은 var처럼 스코프 시작 부분에서 자동으로 초기화되지 않는다는 차이가 있을 뿐입니다.

그럼 TDZ 오류를 피하기 위해 무엇을 해야 할까요?

'let 과 const 선언은 스코프 맨 위에 둬라' 입니다. 이런 식으로 하면 TDZ 길이를 0(또는 0에 가까운)으로 줄일 수 있기 때문에 문제가 없을 겁니다.
