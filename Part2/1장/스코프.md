# 스코프

개발에 입문하고나면 변수를 만들고 변수에 값을 저장하는 데 어느정도 익숙해진다. 변수를 다르는 것은 개발 시 수행하게 되는 가장 기본적인 작업 중 하나이다.

우리가 알아야 할것은 컴퓨터 내부 메모리에 변수가 어떻게 하랑되는지 알아야 한다는게 아니라, 주어진 구문에서 접근 가능한 변수를 JS 엔진이 어떻게 결정하는지와 이름이 같은 두 변수가 있을 때 이를 어떻게 처리하는지 이다. 이런 궁금증을 해소하려면 **스코프** 개념에 대해 알아야 한다.

<br>

## 1.1 JS에 대하여

프로그래밍 언어를 컴파일 언어와 인터프리터를 거치는 스크립트 언어로 구분하면, JS는 일반적으로는 스크립트 언어로 분류된다. 따라서 JS로 작성한 프로그램 대부분은 위에서 아래로 한줄씩 처리된다고 가정된다. 그런데 실제 JS는 **실행 전 별도의 단계에서 파싱, 컴파일**이 일어난다. 개발자가 지정한 변수와 함수, 블록의 위치는 파싱, 컴파일 단계에서 스코프 규칙에 따라 분석되고, 그 결과에 따라 결정된 스코프 구조는 대개 런타임 조건에 영향을 받지 않는다.

JS에서 함수는 일급값이기 때문에 숫자나 문자열처럼 변수에 할당할 수 있고 다른 곳으로 넘기는 것도 가능하다. 그런데 다른 곳으로 넘긴 함수 내에서 외부 변수를 사용하는 경우, 해당 변수는 어딘가에 접근해야 하므로 JS 에서는 함수를 프로그램 내 어디에서 실행했는지와는 상관없이 함수를 정의할 때 결정된 스코프를 유지한다. 이를 **클로저**라고 한다.

모듈은 코드 정리를 도와주는 디자인 패턴으로, 클로저를 통해 공개 메서드가 모듈 내부 스코프에 있는 접근이 제한된 변수나 함수에 접근할 수 있도록 해준다는 특징이 있다.

<br>

## 1.2 컴파일 VS 인터프리트

코드 **컴파일레이션**에 대해 들어봤을 것이다. 컴파일레이션은 소스 코드를 받아들이고 실행 가능한 프로그램 형태로 내뱉는 것 이라고 생각하곤 할 것이다.

컴파일레이션은 텍스트 형식으로 작성한 코드를 처리해서 컴퓨터가 이해할 수 있는 작업 지시 목록으로 바꾸는 일련의 과정이다. 이 과정을 거치면 보통 한 번에 소스코드가 변환되는데, 변호나 결과는 추후에 실행 가능한 형태(대개 파일 형태)로 저장된다.

**인터프리트**도 들어봤을 것이다. 인터프리트와 컴파일의 차이는

**인터프리테이션**은 개발자가 작성한 프로그램을 기계가 해석할 수 있는 명령으로 변환한다는 점에서 컴파일과 유사하다. 하지만 처리 방식이 다르다. 컴파일레이션은 프로그램을 한 번에 처리하는 반면 인터프리테이션은 소스 코드를 한 줄씩 변환한다는데 차이가 있다. 줄 하나 혹은 문 하나는 다음 줄에 있는 소스 코드가 실행되기 바로 직전에 실행된다.

컴파일레이션과 인터프리테이션은 보통 상호 배타적인 모델이라고 한다. 그런데 인터프리테이션은 실제 소스 코드를 한 줄씩 실행하는 방식 말고 다른 방식으로 작동하는 경우가 있어서 이 질문에 답하려면 미묘한 부분을 공부해야 한다. 실제 최신 JS 엔진은 프로그램을 처리할 때 수많은 종류의 컴파일레이션과 인터프리테이션을 사용한다.

<br>

## 1.3 코드 컴파일

먼저 JS가 컴파일 언어인지 아닌지를 따지는게 왜 중요할까? 스코프는 주로 컴파일 중에 결정된다. 따라서 스코프를 정복하려면 컴파일레이션과 실행이 어떻게 연관되는지 이해하는게 중요하다. 고전 컴파일러 이론에는 프로그램이 컴파일러의 다음 세 가지 주요 단계를 거쳐 처리된다고 정의한다.

- **1단계 토크나이징/렉싱**: 문자열을 토큰이라 불리는 조각으로 쪼갠다. `var a = 2;` 라는 코드가 있다고 가정하고, 1단계를 거치면 이 코드는 `var`, `a`, `=`, `2`, `;`로 조각난다. 띄어쓰기 같은 공백은 토큰이 될 수도 있고 안ㄷ 될 수도 있는데, 공백이 해당 프로그래밍 언어에서 의미가 있는지 없는지에 따라 토큰이 될지 아닐지가 결정된다. 토크나이징과 렉싱엔 미묘하고 학술적인 차이가 있는데, 둘의 차이는 토큰을 무상태 방식으로 인식하는지와 상태 유지 방식으로 인식하는지에 있다. 쉽게 설명하면 토크나이저가 a를 별개의 토큰으로 분리할지 아니면 다른 토큰의 일부로 처리할지를 결정할 때 상태 유지 파싱 규칙을 적용한다면 이는 렉싱이다.

- **2단계 파싱**: 토큰 배열을 프로그램 문법 구조를 반영하는 중첩 원소 기반의 트리인 AST(추상 구문 트리)로 바꾼다. 코드 `var a = 2;`는 파싱을 거치면 변수 선언 이라 불리는 최상위 노드와 A의 값을 가지는 식별자 노드, 할당식이라 불리는 노드를 자식 노드로 가진 트리가 된다. 여기서 할당식 노드는 2라는 값을 가지는 숫자 리터럴을 자식 노드로 갖는다.

- **3단계 코드 생성**: AST를 컴퓨터가 실행 가능한 코드로 변환한다. 코드 생성 단계는 언어 혹은 목표하는 플랫폼 등에 따라 크게 달라진다. 정리하자면 JS 엔진은 `var a = 2;`라는 코드를 AST로 바꾸고 AST를 컴퓨터가 실행 가능한 코드로 바꾸는데, 이 과정에서 실제 a라는 변수가 생성되고(메모리 확보 등도 같이 진행됨0, 그 후 변수 A에 2가 저장되는 것이다.

사실 JS 엔진은 앞서 세 단계로 설명한 것보다 훨씬 복잡하게 돌아간다. 파싱과 코드 생성 단계에서 실행 최적화를 위해 몇 가지 추가 작업(불필요한 중복 요소 제거 등)이 진행된다. 여기에 더해 프로그램 실행 중 컴파일이나 최적화를 다시 하는 경우도 있다.

다른 언어와 달리 JS 컴파일레이션은 구축 단계에서 일어나는게 아니기 때문에 JS 엔진은 충분한 시간을 확보하지 못한 채 맡은 임무나 최적화를 수행한다. 컴파일레이션은 보통 코드가 실행되기 전, 수백만분의 일초 내에 완료되어야 한다. 이러한 제약 아래 가장 빠른 성능을 보장하기 위해 JS 엔진은 가능한 한 모든 종류의 꼼수(레이지 컴파일이나 핫 리컴파일 같은 JIT) 를 사용한다.

<br>

### 1.3.1 필수 두 단계

JS가 어떻게 프로그램을 처리하는지 관찰할 때 중점적으로 봐야 할 것은 프로그램 처리는 (최소) **파싱과 컴파일** 이라는 두 단계에서 일어난다는 사실이다. 간단히 설명하면 파싱과 컴파일이 먼저 일어나고 그 다음에 실행이 된다고 볼 수 있다.

파싱과 컴파일이 후속 절차인 실행 단계와 구분된다는 점은 이론이거나 개인적인 의견이 아니고 개발자가 직접 관찰할 수 있는 팩트이다. ECMA 명세서에 “컴파일레이션이 반드시 필요하다” 고 적혀 있진 않지만 **선 컴파일 후 실행** 접근 방식을 취하지 않으면 명세서에서 요구하는 동작을 충족할 수 없다.

선 컴파일 후 실행 접근 방식을 입증할 수 있는 JS만의 세 가지 특징으로는 구문 오류, 초기 오류, 호이스팅이 있다.

<br>

### 구문 오류

```jsx
 var greeting = "안녕하세요.";

 console.log(greeting);
 greeting = ."안녕!";
 // SyntaxError: unexpected token.
```

예시를 실행하면 “안녕!” 문자열 앞에 있는 온점 때문에 “안녕하세요.” 가 출력되지 않고 **SyntaxError** 가 발생한다. JS가 위에서 아래로 한 줄씩 실행된다고 생각하는 사람은 `console.log()` 까지는 문법상 문제가 없고 그 다음 코드에 문법상 오류가 있기 때문에 “안녕하세요.”라는 문자열이 정상적으로 출력된 다음, 구문 오류가 발생했다는 로그가 찍힐거라고 생각할 수 있는데 그런 일은 일어나지 않는다.

JS 엔진 입장에서 세 번째 줄에 구문 오류가 있다는 사실을 알 수 있는 유일한 방법은 첫째 줄과 둘째 줄을 실행하기 전, 즉 프로그램을 실행하기 전에 전체 프로그램을 먼저 파싱하는 방법 뿐이다.

<br>

### 초기 오류

```jsx
console.log("잘 지내시죠?");

saySomething("안녕하세요.", "안녕!");
// Uncaught SyntaxError: Duplicate parameter name not allowed in this context

function saySomething(greeting, greeting) {
  "use strict";
  console.log(greeting);
}
```

첫째 줄에는 문제가 없지만 예씨를 실행하면 **“잘 지내시죠?”** 라는 메시지가 출력되지 않는다.

대신 구문 오류에 봤던 프로그램 실행 전 **SyntaxError** 가 출력된다. 오류가 발생한 이유는 엄격모드 때문인데, 엄격 모드에서는 이름이 같은 함수 매개변수가 허용되지 않는다.(비엄격모드에서는 적용안됨)

예시의 오류는 구문 오류 처럼 **“안녕!”** 앞에 있는 온점(.) 때문에 발생한 오류가 아니다. ECMA 명세서에 따르면 엄격 모드에서 프로그램을 실행할 때, 가이드를 어긴 경우 초기 오류를 발생시키는데, 이 오류가 바로 초기 오류이다.

JS 엔진은 이런 오류들이 어떻게 떴는지 어떻게 알았을까? **프로그램 실행 전에 코드 전체가 파싱된다는 가정**만이 이런 현상을 설명할 수 있는 유일한 답이다.

<br>

### 호이스팅

```jsx
function saySomething() {
  var greeting = "안녕하세요.";
  {
    greeting = "잘 지내시죠?"; // 여기서 오류 발생
    let greeting = "안녕!";
    console.log(greeting);
  }
}

saySomething();
// ReferenceError: Cannot access "greeting" before initialization
```

콘솔에 출력되는 `ReferenceError` 는 `greeting = “잘 지내시죠?”`가 있는 줄에서 발생한다. 여기서 변수 `greeting`은 `var greeting = “안녕하세요.”`가 아닌 그 다음 줄인 `let greeting = “안녕!”` 에서 선언이 이뤄진다.

JS 엔진 입장에서 다음 구문에서 이름(greeting)이 같고 스코프는 블록인 변수가 선언되었기 때문에 오류가 발생했다는 것을 알 수 있는 유일한 방법은 오류가 발생한 문이 실행되기 전, 프로그램 내 스코프와 변수 관계 전부를 사전에 파악하는 것뿐이다. 프로그램이 실행되기 전 파싱이 이뤄져야만 이런 스코프와 선언에 관한 처리가 정확해지는 것이다. 예시에서 `ReferenceError` 는 코드 `greeting = “잘 지내시죠?”` 에서 변수 `greeting`에 너무 빨리 접근하려 해서 발생하는 에러이다.

이러한 내용들로 JS로 작성한 프로그램은 실행 전에 파싱된다는 것을 확신할 수 있다. JS를 컴파일 언어로 분류하는 건 실행 가능한 바이너리(혹은 바이트코드) 파일이 생성되는 배포 모델과 관련이 없다. 대신 JS를 컴파일 언어로 분류할 때는 JS로 작성한 코드는 처리 및 분석 시 여러 절차를 거치는데 이 절차들은 코드 실행 전 반드시 일어나고 이는 논란의 여지가 없으며 실제로도 관찰 가능하다고 생각하자.

<br>

## 1.4 컴파일러체

JS 프로그램은 두 단계(컴파일 후 실행)에 걸쳐 처리된다는 지식을 바탕으로 JS 엔진이 어떻게 변수를 식별하는지와 컴파일 후 프로그램의 스코프를 결정하는지 알아보자.

```jsx
var students = [
	{ id: 45, name: "성한" }
	{ id: 73, name: "기원" }
	{ id: 112, name: "성준" }
	{ id: 7, name: "민지" }
];

function getStudentName(studentID) {
	for (let student of students) {
		if (student.id == studentID) {
			return student.name;
		}
	}
}

var nextStudent = getStudent(112);

console.log(nextStudent);
// 성준
```

선언을 제외하고 프로그램 내 모든 변수와 식별자는 할당의 **타깃** 이나 값의 **소스** 둘 중 하나의 역할을 한다. 할당된 값이 있다면 변수는 할당의 ‘타깃’ 이고 그렇지 않으면 변수의 값은 ‘소스; 가 된다.

변수 처리를 위해 JS 엔진은 변수가 나탄라 때마다 가장 먼저 변수 각각에 타깃과 소스라는 역할 이름표를 붙인다.

<br>

### 1.4.1 할당의 타깃

```jsx
students = [ // ...
```

위 문은 명백히 할당 연산이다.

예시 코드의 `nextStudent = getStudent(112)` 도 역시 할당 연산이다. 그런데 직접 할당 연산자를 쓴 두 코드 조각 이외에도 프로그램 내에는 세 개의 타깃 할당 연산이 쓰였다.

```jsx
for (let student of students) {
```

위 문은 루프가 돌 때마다 `student` 에 값을 할당한다.

```jsx
getStudent(112);
```

타깃과 무관해 보이는 코드이다. 인수 `112`는 매개변수 `studentID` 에 할당되기 때문이다.

```jsx
function getStudentName(studentID) {
```

마지막 할당 타깃은 바로 이 코드이다. function 키워드로 선언한 함수 선언은 타깃 참조의 특수한 케이스이다. 함수 선언이 할당 타깃의 예라고 하면 `var getStudentName = function(studentID)` 와 유사하다고 느낄 수 있는데, 코드에서 식별자 `getStudentName` 은 컴파일 타임에 선언되고 `= function(studentID)` 역시 컴파일레이션 과정에서 처리된다.

그리고 `getStudent` 과 함수의 관계는 할당문이 실행될 때 설정되는 게 아니라 스코프가 구성되기 시작하는 시점에 자동으로 설정된다. (이렇게 함수와 변수의 관계가 자동으로 설정되는 것을 함수 호이스팅이라고 한다)

<br>

### 1.4.2 값의 소스

앞서 `for (let student of students)` 를 다룬 부분에서 `student` 는 타깃이라고 설명한적이 있다. 그러나 여기서 `students` 는 소스 참조이다. 조건문 `if (student.id == studentID)` 에서 `student` 와 `studentID` 는 둘 다 소스 참조인데, 특히 `student`는 `return student.name` 에서 소스 참조 역할을 한다.

`getStudent(112)` 에서 `getStudentName` 은 함수 참좃값의 소스 참조이다. `console.log(nextStudent)` 에서 `console`은 소스 참조이며 `nextStudent` 역시 마찬가지이다.

타깃과 소스를 구분해서 이해해야 한다. 변수의 역할이 변수를 찾는데 어떤 영향을 미치는지 알아야 하기 때문이다.

<br>

### 1.5 런타임에 스코프 변경하기

스코프는 프로그램이 컴파일될 때 결정되고, 런타임 환경에는 영향을 받지 않는다는게 명확해졌을 것이다. 그런데 비엄격 모드에서는 런타임에도 프로그램의 스코프를 수정할 수 있는 방법 두 가지가 있다.

그러나 사용이 지양되고 있다. 위험하고 혼란스럽게 할 수 있기 때문이다.

첫 번째 방법은 `eval()` 함수이다. `eval()` 은 컴파일과 실행의 대상이 되는 문자열 형태의 소스 코드를 받는데 이 소스 코드는 런타임에 컴파일이 실행된다. `eval()` 에 넘기는 소스 코드에 `var`나 `function` 선언이 있는 경우, 이 선언들은 `eval()` 이 실행 중인 스코프를 변경한다.

```jsx
function badIdea() {
  eval("var oops = '웁스';");
  console.log(oops);
}
badIdea(); // 웁스
```

`eval()` 을 사용한 줄이 없었다면 `console.log(oops)` 에서 `oops` 를 찾을 수 없기 때문에 `ReferenceError` 가 발생했을 것이다. 하지만 `eval()` 이 런타임에 `badIdea()` 의 스코프를 수정했기 때문에 오류가 발생하지 않는다. `eval()` 을 쓰지 말아야 하는 이유는 아주 많고, 대표적인 이유는 성능 때문이다. `badIdea()` 가 실행될 때마다 컴파일과 최적화가 이미 끝난 스코프를 다시 수정하기 때문에 CPU 자원을 쓸 수 밖에 없다.

`with` 키워드 역시 런타임에 스코프 수정을 가능하게 한다. `with` 는 특정 객체의 스코프를 지역 스코프로 동적으로 변환한다. 이렇게 스코프가 변환되면 새로운 지역 스코프에서는 객체의 프로퍼티가 식별자가 되기 때문에 객체를 통하지 않고 바로 사용할 수 있다.

```jsx
var badIdea = { oops: "웁스" };

with (badIdea) {
  console.log(oops); // 웁스
}
```

예시에서 전역 스코프는 수정되지 않는다. 하지만 컴파일 타임이 아닌 런타임에 `badIdea` 자체가 스코프로 변하기 때문에 이 스코프 안에서 `badIdea` 의 프로퍼티 `oops` 는 변수가 된다. `with` 를 사용하는 것 역시 성능과 가독성 측면에서 좋지 않으니 사용하지 않는게 좋다.

<br>

## 1.6 렉시컬 스코프

컴파일 타임에 결정되는 스코프를 **렉시컬 스코프(어휘 스코프)** 라고 한다. 렉시컬 스코프에서 렉시컬은 컴파일레이션 세 단계 중 렉싱과 관련이 있다.

렉시컬 스코프의 핵심은 함수나 블록, 변수 선언의 스코프는 전적으로 코드 배치에 따라 제한된다는 점이다.

함수 안에 변수를 선언하면 컴파일러는 함수를 파싱할 때 변수 선언을 처리하고 함수의 스코프와 선언을 연결한다. 그런데 변수를 블록 스코프(let, const) 로 선언했따면 (var로 선언한 것과 달리) 스코프는 함수 범위가 아니고 가장 가까운 블록이 된다.

여기에 더해 변수 참조(타깃 역할을 하는지, 또는 소스 역할을 하는지)는 해당 변수가 **렉시컬 적으로 사용 가능한** 여러 스코프 중 하나에서 결정되어야만 한다. 그렇지 않으면 변수가 선언하지 않은 상태가 되어 높은 확률로 오류가 발생한다. 변수가 현재 스코프에 선언되어 있지 않은 경우엔 다음 외부(감싸는) 스코프를 참조한다. 이런 프로세스는 식별자가 일치하는 변수 선언을 찾거나 전역 범위에 도달해 더 이상 찾을 곳이 없을 때까지 계속된다.

컴파일레이션은 스코프와 변수의 메모리 예약 관점에서 실제로는 아무것도 하지 않는다는 게 중요하다.

대신 컴파일 도중에는 프로그램 실행에 필요한 모든 렉시컬 스코프가 들어간 지도가 만들어진다. 런타임에 사용할 모든 코드가 들어간 계획안이 이때 만들어진다고 생각하면 된다. 여기에는 렉시컬 환경이라고 칭해지는 스코프가 전부 정의되고 각 스코프에 해당하는 식별자(변수) 가 추가된다.

즉, 컴파일 중에는 스코프를 식별하기만 하고 실제 각 스코프를 실행해야만 하는 런타임 전까지는 스코프가 생성되지 않는다.
