# 스코프 노출 제한

## 6.1 전역 스코프를 배워야 하는 이유

함수의 전용 스코프를 생성한다는 건 이치에 맞는 일입니다. 그런데 블록은 왜 스코프가 필요한 걸까요?

소프트웨어 공학, 특히 정보 보안 분야에는 **최소 권한의 원칙**(**POLP**: principle of least privilege)이라는 규율이 존재합니다. 이 원칙을 약간 변형한 **최소 노출의 원칙**(**POLE**: principle of least exposure)을 현재 논의 중인 내용에 적용해봅시다.

POLP는 시스템 구성 요소에는 최소한의 권한을 부여하고 접근도 최소화하며 노출 역시 최소화해야 한다는 설계 원칙으로, 방어적인 아키텍쳐 설계를 대변합니다. POLP를 기반으로 아키텍처를 설계해 각 구성 요소가 필요한 최소한의 기능으로 연결되면, 한 구성 요소의 손상이나 장애가 나머지 시스템에 미치는 영향이 최소화되므로 시스템 전체 보안이 더 강력해진다는 장점이 있습니다.

POLP가 시스템 수준의 컴포넌트 설계에 집중한다면 POLP의 변형인 POLE은 조금 더 낮은 수준의 설계에 집중합니다. 이 방식을 스코프가 상호작용하는 방식에 적용해보겠습니다.

POLE을 따른다고 했을 때 노출을 최소화하고 싶은 항목은 무엇이 될까요? 결론부터 말하자면 스코프마다 등록된 변수의 노출입니다.

프로그램의 모든 변수를 전역 스코프에 배치하면 안 되는 이유는 무엇일까요?<br> 프로그램의 한 부분에서 사용할 변수를 스코프를 통해 다른 스코프에 노출시키면 다음과 같은 세 가지 위험한 상황이 발생합니다.

- **이름 충돌**: 프로그램의 여러 부분에서 범용적인 이름을 가진 변수/함수를 사용하는데, 이 함수/변수의 식별자가 전역 스코프 같은 공유 스코프에서 나온 경우 이름 충돌이 발생합니다. 이런 경우는 예상치 못한 방식으로 변수나 함수를 사용할 수 있어 버그가 발생할 확률이 매우 높습니다. 모든 반복문에서 하나의 전용 인덱스용 변수 i를 사용한다고 가정해봅시다. 이 경우 A라는 함수의 반복문이 B라는 함수의 반복문과 동시에 실행되는 경우, 공유된 변수 i가 예상치 못한 값으로 변경될 수 있습니다.
- **예기치 않은 작동**: 비공개(private) 변수/함수를 프로그램 내부에 노출하면, 다른 개발자가 의도하지 않은 방식으로 변수나 함수를 사용할 수 있습니다. 이렇게 하면 의도하지 않은 작동이 발생하고 버그가 발생합니다. 숫자만 관리하는 배열이 따로 있고, 숫자를 사용하고 싶을 때는 이 배열에 접근해서 숫자를 얻어 온다고 가정해봅시다. 어디선가 이 배열에 불리언이나 문자열을 추가할 수 있다면 코드가 예기치 않게 오작동할 수 있습니다. 개인 정보를 담고 있는 변수나 함수가 노출되면 악의를 가진 이들이 우리가 설정한 제한을 우회해 도용할 수 있다는 위험도 생깁니다.
- **의도하지 않은 종속성**: 변수나 함수가 불필요하게 노출되면 다른 개발자가 비공개로 처리된 변수/함수를 사용하고 여기에 의존하기까지 할 수 있습니다. 이런 행동이 당장 프로그램을 손상하지는 않지만, 향후 리팩터링 시 좋지 않습니다. 우리가 제어할 수 없는 비공개 변수/함수를 건드리지 않고는 리팩터링을 쉽게 할 수 없기 때문입니다. 비공개 숫자 배열에 의존하는 코드를 작성했다고 가정해보면 나중에 배열 대신 다른 자료구조로 리팩터링을 진행할 때 의존성 때문에 해당 코드뿐만 아니라 다른 부분도 수정해야 할 수 있습니다.

<br>

POLE은 변수/함수 스코프 지정 시 기본적으로 필요한 최소한의 것만 노출하고 나머지는 가능한 한 비공개로 유지하도록 제안합니다. 모든 것을 전역(또는 외부 함수) 스코프에 담기보다 가능한 한 작고 깊게 중첩된 스코프에 변수를 선언하는 식입니다.

이 기준으로 소프트웨어를 설계한다면 앞선 세 가지 위험을 피하거나 위험을 최소화할 수 있습니다. 다음 코드를 살펴보겠습니다.

```js
function diff(x, y) {
  if (x > y) {
    let tmp = x;
    x = y;
    y = tmp;
  }

  return y - x;
}

diff(3, 7); // 4
diff(7, 5); // 2
```

diff() 함수에서 반환값(y - x)이 0보다 크거나 같게 하려면 y가 x보다 크거나 같아야 합니다. x가 y보다 더 크면 반환값이 음수가 되므로 이를 방지하기 위해 tmp 변수를 사용해 x와 y를 바꿔 차를 구합니다.

이처럼 간단한 예시에서 tmp가 if 블록 안에 있든 함수 수준에 속해 있는 게 중요하지 않아 보일 수 있지만, tmp는 전역 변수가 되어서는 안 됩니다. tmp는 POLE에 따라 스코프 내에 최대한 숨겨져 있어야 합니다. 이렇게 if 블록 안에서 let을 사용해 tmp를 선언하면 tmp의 스코프를 블록으로 차단할 수 있습니다.

<br>

## 6.2 일반(함수) 스코프에 숨기기

가능한 한 가장 낮은 스코프(가장 깊은 중첩 스코프)에 변수와 함수 선언을 숨기는 게 왜 중요한지 알아봤습니다. 그럼 이를 어떻게 실천할 수 있을까요?

스코프 내에 var나 함수 선언을 숨기는 방식은 어떨지 생각해보면, 함수 스코프로 이들을 감싼다면 충분히 숨기는 게 가능할 것입니다.

함수 스코프 지정이 유용한 경우는 다음과 같습니다.

계승(**factorial**: _느낌표로 표기함_)은 1에서 n까지의 모든 정수를 곱하는 것입니다. 수학 연산으로 1은 곱하면 아무 소용이 없기 때문에 계승에서는 한 번 계산된 정수의 계승을 다시 계산할 필요가 없습니다. 6!의 결과는 6 x 5!와 같고, 이는 다시 6 x 5 x 4!와 같기 때문입니다.

한 번 6!을 계산한 이후에 7!을 계산해야 하는 경우, 아무런 생각 없이 코드를 짠다면 2부터 6까지 모든 정수를 다시 곱하게 될 수 있습니다. 하지만 각 정수의 계승을 계산하고 그 결과를 캐시에 저장하게 되면 메모리를 희생하긴 하지만 대신 계산 낭비를 없애 속도를 높일 수 있습니다.

```js
var cache = {};

function factorial(x) {
  if (x < 2) return 1;
  if (!(x in cache)) {
    cache[x] = x * factorial(x - 1);
  }

  return cache[x];
}

factorial(6);
// 720

cache;
// {
//   "2": 2,
//   "3": 6,
//   "4": 24,
//   "5": 120,
//   "6": 720
// }

factorial(7);
// 5040
```

이렇게 코드를 작성하면 이전에 계산한 결과가 cache에 저장되므로 factorial() 을 여러번 호출해도 처음부터 계산을 다 하지 않아도 됩니다. 그런데 여기서 주목해야 할 점은 cache 변수는 factorial()의 작동 방식을 나타내는 비공개 변수라는 점입니다. 외부 스코프, 특히 전역 스코프에 있는 변수가 아니므로 노출되면 안 되는 비밀스러운 변수입니다.

> 🗒️ NOTE <br><br>
> 여기서 구현한 factorial()은 내부에서 자기 자신을 호출하는 재귀 함수인데, 코드 간결성을 위해 재귀함수로 작성한 것뿐입니다. factorial()을 비재귀적으로 구현해도, 스코프 분석 관점에서 cache 변수의 스코프 관련 부석은 동일하게 적용됩니다.

<br>

그런데 cache 변수를 factorial() 함수 내부로 숨기는 것으로는 문제를 해결할 수 없습니다.
cache 변수는 호출이 여러 번 일어나는 경우에도 유지되어야 하므로 함수 외부 스코프에 있어야 합니다. 그럼 어떻게 코드를 수정해야 할까요?

다음과 같이 외부/전역 스코프와 내부 factorial() 사이에 cache가 위치할 중간 스코프를 정의하면 됩니다.

```js
// 외부/전역 스코프

function hideTheCache() {
  // cache를 숨길 중간 스코프
  var cache = {};

  return factorial;
  // **************************
  function factorial(x) {
    // inner scope
    if (x < 2) return 1;
    if (!(x in cache)) {
      cache[x] = x * factorial(x - 1);
    }

    return cache[x];
  }
}

var factorial = hideTheCache();

factorial(6);
// 720

factorial(7);
// 5040
```

hideTheCache() 함수는 factorial()을 여러 번 호출하는 동안 cache를 지속시킬 스코프를 만드는 것 외에는 용도가 없습니다. 그런데 factorial()이 cache에 접근할 수 있게 하려면 동일한 스코프에 factorial()을 정의해야 합니다. 그다음 hideTheCache()에서 factorial 함수를 반환하도록 하고 이 함수 참조를 외부 스코프인 factorial에 저장합니다. 이렇게 하면 factorial()을 여러 번 호출할 때, factorial 내부에서만 숨겨진 cache를 접근할 수 있게 됩니다.

그런데 변수나 함수를 숨겨야 할 때마다 hideTheCache()처럼 새 함수와 스코프를 만드는 건 귀찮은 일입니다.

변수나 함수를 숨겨야 하는 상황이 생기면 특이한 이름을 가진 함수를 정의하는 것보다 함수 표현식을 사용하는 게 더 나은 해결책이 될 수 있습니다.

```js
var factorial = (function hideTheCache() {
  var cache = {};

  function factorial(x) {
    if (x < 2) return 1;
    if (!(x in cache)) {
      cache[x] = x * factorial(x - 1);
    }

    return cache[x];
  }

  return factorial;
})();

factorial(6);
// 720

factorial(7);
// 5040
```

hideTheCache는 함수 선언이 아닌 함수 표현식으로 정의했으므로 이름은 외부/전역 스코프가 아닌 자체 스코프(cache와 같은 스코프)에 존재하게 됩니다.

이렇게 하면 함수 표현식에 동일한 이름을 지정할 수 있고 충돌이 발생하지 않습니다. 더 나아가 숨기려는 것에 따라 이름을 적절히 지어 지정할 수도 있습니다. 어떤 이름이든 프로그램 내부의 다른 함수 표현식과 충돌하지 않을까 걱정하지 않아도 됩니다.

사실은 이름을 완전히 생략하고 **익명 함수 표현식**으로 정의할 수도 있습니다.

<br>

## 6.2.1 함수 표현식 즉시 호출하기

이전 계승 재귀 프로그램에서 놓치기 쉬운 중요한 부분이 있는데, 바로 function 표현식 마지막 줄에 있는 })(); 입니다.

예시에서 function 표현식 전체를 ()로 감싸고, 마지막 부분에 두 번째()를 추가했습니다.
두 번째()는 방금 정의한 function 표현식을 호출하는 역할을 합니다. 첫 번째로 함수 표현식을 둘러싼 ()는 엄밀히 말하자면 필수는 아닙니다. 여기서는 가독성을 위해 사용했습니다.

정리하자면, 예시는 즉시 호출되는 함수 표현식을 사용했는데, 이 패턴은 **IIFE**(**즉시 실행 함수 표현식**: _immediately invoked function expression_)라는 이름으로 불립니다.

IIFE는 변수나 함수를 숨기는 스코프를 만들고 싶을 때 유용합니다. 표현식이므로 JS프로그램에서 표현식이 허용되는 곳이라면 어디서나 사용할 수 있습니다. IIFE는 hideTheCache()와 같이 이름을 붙일 수 있고, 익명으로 지정할 수 있습니다. 이 함수는 독립적일 수 있고, 다른 구문의 일부가 될 수도 있습니다. hideTheCache()는 factorial()함수 참조를 반환하고, 이 참조는 =으로 factorial 변수에 할당됩니다.

독립형 IIFE의 예시는 다음과 같습니다.

```js
// 외부 스코프

(function () {
  // 내부에 숨겨진 스코프
})();

// 더 많은 외부 스코프
```

이전 예시에서 외부를 감싸고 있던 ()의 사용이 선택할 수 있는 옵션이었다면, 독립형 IIFE에서는 ()를 필수로 사용해야 합니다. 독립형 IIFE에서는 함수를 문이 아닌 표현식으로 구분합니다. 다만 일관성을 위해 IIFE의 function을 항상 ()로 묶어야 합니다.

<br>

### 함수의 경계

---

스코프를 정의할 목적으로 IIFE를 사용하면 주변 코드에 따라 의도하지 않은 결과가 발생할 수 있으므로 주의해야 합니다. 왜냐하면 IIFE도 온전한 함수이기 때문에 IIFE를 사용하면 함수 경계가 변경되는데 이는 문이나 구조의 동작을 바꿀 수 있기 때문입니다.

코드에 return 문이 있다고 가정해봅시다. 이 코드를 IIFE가 둘러싸게 되면 return은 IIFE 함수를 참조하게 되어서 해당 코드의 반환값이 IIFE의 반환값이 되어버립니다. 화살표 함수가 아닌 일반 함수의 형태의 IIFE를 사용하면 this의 바인딩도 바뀝니다.<br>
그리고 break나 continue 문은 IIFE 경계를 넘어서 작동하지 않으므로 이들로 함수 경계 밖의 제어문을 통제할 수 없다는 점도 주의해야 합니다.

따라서 스코프를 감싸는 코드에 return, this, break, continue가 포함된 경우라면 아마도 IIFE가 최선의 접근 방식이 아닐 수 있습니다. 이 경우에는 함수 대신 블록을 사용해 스코프를 만드는게 좋습니다.

<br>

## 6.3 블록으로 스코프 지정

이제부터는 중첩 블록 내에서 let 선언을 사용하는 방법을 고려해봅시다.

블록은 let이나 const 같은 블록 스코프 선언을 포함해야 할 필요가 있을 때만 스코프로 작용합니다. 다음 코드를 살펴봅시다.

```js
{
  // 아직 스코프가 필요하지 않습니다.

  // ...

  // 이제 블록이 스코프여야 한다는 것을 인지했습니다.
  let thisIsNowAScope = true;

  for (let i = 0; i < 5; i++) {
    // 여기도 스코프인데
    // 이터레이션마다 각각 활성화됩니다.
    if (i % 2 == 0) {
      // 여기는 스코프가 아닌 블록일 뿐입니다.
      console.log(i);
    }
  }
}
// 0 2 4
```

다음 경우와 같이 모든 중괄호 쌍이 항상 블록 스코프를 생성하는 건 아닙니다.(스코프가 될 자격은 있습니다)

- 객체 리터럴은 {}를 사용해 키-값 목록을 구분하지만, 이러한 객체값이 스코프는 아닙니다.
- class는 {}를 사용해 본문을 정의하는데, 이는 블록이나 스코프가 아닙니다.
- function은 본문을 감쌀 때 {}를 사용하는데, 엄밀히 말해 이는 블록이 아니라 함수 본문을 나타내는 단일 문이므로 블록 스코프를 형성하지 않습니다. 이때 중괄호는 함수 스코프를 생성합니다.
- case 절 주변의 switch 구문에 사용된 {}로는 블록이나 스코프를 정의할 수 없습니다.

앞서 본 중괄호 쌍이 실제 블록이 아니다는 것을 설명하는 예시 말고도 중괄호 쌍은 다양한 방식으로 사용할 수 있습니다. 중괄호 쌍을 if나 for 문과 함께 사용할 수도 있습니다. 이 경우는 중괄호 내의 코드가 해당 문의 블록으로 간주되어 문의 일부로 취급됩니다. 중괄호를 단독으로 사용할 수도 있습니다. <br>다만 바로 앞 예시에서 가장 바깥쪽 중괄호 쌍을 보면, 이렇게 명시적으로 블록을 만드는 게 의미적인 신호가 될 순 있지만 블록 내부에 선언이 없다면 중괄호 쌍은 스코프를 만들지 않고 실행 동작에도 영향을 끼치지 않습니다.

참고로 중괄호를 단독으로 쓰는 방식은 유효한 JS 문법이었으나 ES6에서 let/const가 추가되기 전에는 스코프를 형성할 수 없어서 잘 사용하지 않았습니다. ES6 이후에 조금씩 사용하는 사람들이 생기기 시작했습니다.

블록 스코프를 지원하는 대부분의 프로그래밍 언어에서 명시적으로 블록 스코프를 만드는 건 변수의 범위를 좁히는 일반적인 패턴입니다. 따라서 POLE에 따라 JS에서도 이런 패턴이 보편화되어야 한다고 생각해야 합니다. 식별자가 노출될 수 있는 범위를 최소한으로 줄이려면(명시적) 블록스코프를 사용하세요.

명시적 블록 스코프는 (외부 블록이 스코프인지 여부에 관계없이) 다른 블록 안에서도 유용할 수 있습니다.

예시를 살펴보겠습니다.

```js
if (somethingHappened) {
  // 이것은 블록이지만, 스코프는 아닙니다.

  {
    // 이것은 블록이면서 명시적 스코프입니다.
    let msg = somethingHappened.message();
    notifyOthers(msg);
  }

  // ...

  recoverFromSomething();
}
```

여기서 if 문 내부의 {} 중괄호는 작은 명시적인 내부 블록 스코프를 나타내며, msg 변수는 전체 if 블록에서 필요하지 않기 때문에 해당 블록 스코프로 제한했습니다. 그런데 많은 개발자가 이런 경우, msg를 if 블록에 선언하곤 합니다. <br>코드가 짧을 경우에는 어디에 변수를 선언하는지가 그리 중요하지 않을 수 있습니다. 그러나 코드가 길어지면 과도한 노출 문제가 더욱 부각됩니다.

그럼 추가적인 {}와 들여쓰기를 사용해 명시적인 내부 블록 스코프를 정의하는 것은 괜찮습니다.
POLE을 따르기 위해 항상 합리적인 사고로 각 변수에 대해 가장 작은 블록을 정의하는 것이 좋습니다.

이번에는 실질적인 예시를 보겠습니다.

```js
function sortedNamesByLength(names) {
  var buckets = [];

  for (let firstName of names) {
    if (buckets[firstName.length] == null) {
      buckets[firstName.length] = [];
    }

    buckets[firstName.length].push(firstName);
  }

  // 스코프를 좁히는 블록
  {
    let sortedNames = [];

    for (let bucket of buckets) {
      if (bucket) {
        // 각 bucket을 알파벳순으로 정렬
        bucket.sort();

        // 정렬된 이름을 실행 목록에 추가
        sortedNames = [...sortedNames, ...bucket];
      }
    }

    return sortedNames;
  }
}

sortedNamesByLength(["Sally", "Suzy", "Frank", "John", "Jennifer", "Scott"]);
// ["John", "Suzy", "Frank", "Sally", "Scott", "Jennifer"]
```

총 다섯 개의 스코프(for (let firstName of names))에 여섯 개의 식별자가 선언되어 있습니다. 변수 모두를 하나의 외부/전역 스코프에 선언하는 게 기술적으로 불가능하진 않습니다. 변수들의 이름이 달라 이름 충돌이 없기 때문입니다. 그러나 이렇게 모든 변수를 하나의 스코프에서 선언하면 코드 구조가 혼란스러워지고, 향후 버그 유발 가능성이 커집니다.

그래서 예시에서는 변수를 각각의 내부 중첩 스코프에 적절하게 분할했습니다. 그리고 생각한 로직대로 프로그램이 작동할 수 있게 각 변수를 최대한 안쪽 스코프에 정의했습니다.

sortedNames를 최상위 함수 스코프에서 정의할 수 있지만, 이 변수는 함수의 후반부에서만 필요합니다. 따라서 변수가 상위 레벨 스코프에 과도하게 노출되지 않도록 POLE에 따라 내부 명시적 블록 스코프에 블록 스코프를 지정했습니다.

<br>

### 6.3.1 var와 let

---

이번에는 앞선 예시의 var buckets 선언에 관해 이야기해 보겠습니다. buckets은 마지막 return 문을 제외하고 함수 전체에서 사용되는 변수입니다. 이렇게 함수 전체(또는 대부분)에 걸쳐 필요한 변수는 그 용도가 분명하도록 선언해야 합니다.

> 🗒️ NOTE <br><br>
> 매개변수 name은 함수 전체에서 사용되지는 않지만 매개변수의 범위를 제한할 방법이 없으므로 함수 전체 선언으로 작동합니다.

<br>

그런데 buckets 변수를 선언할 때 let 대신 var를 사용했습니다. 그 이유, var를 사용하는 데는 의미론적, 기술적 이유가 있습니다.

JS의 초장기부터 var는 '전체 함수에 속한 변수'를 의미했습니다. 1.6절 '렉시컬 스코프'에서 주장한 것처럼 var는 사용된 위치와 상관없이 가장 가깝게 감싼 함수 스코프에 붙습니다. 이는 var가 블록 안에 나타나는 경우에도 마찬가지 입니다.

```js
function diff(x, y) {
  if (x > y) {
    var tmp = x; // tmp는 함수 스코프입니다.
    x = y;
    y = tmp;
  }

  return y - x;
}
```

선언은 블록 스코프가 아닌 함수 스코프(diff()까지)에서 이뤄집니다.

예시처럼 var 블록 내에서 선언할 수 있지만(여전히 함수 스코프 변수), 예외 상황을 제외하고는 함수의 최상위 스코프에서 var를 사용하는게 좋습니다.

var는 let과 시각적으로 구분되므로 var를 쓰면 '이 변수는 함수 스코프'라는 신호를 명확하게 전달할 수 있습니다. 특히 블록의 다른 모든 선언이 let을 사용하는 와중에 함수의 처음 몇 줄이 아닌 최상위 스코프에서 var를 사용하면 이 변수는 함수 스코프 선언이라는 걸 시각적으로 명확히 할 수 있습니다.

var가 let보다 효과적으로 함수 스코프라는 걸 알릴 수 있다고 생각합니다. 반면 let은 블록 스코프 전달에 더 효과적이라고 생각합니다. 프로그램에 함수 스코프 변수와 블록 스코프 변수 모두가 필요하다면, 가장 합리적이고 가독성이 높은 방식은 var와 let을 각각의 목적에 맞게 함께 사용하는 것입니다.

> ❗️ **WARNING** <br><br>
> var와 let을 모두 사용하라는 이 책의 저자 "카일 심슨"의 제안은 논란의 여지가 있고, 다수의 의견과 대립됩니다. 하나의 의견이라고 생각하고, var는 결함이 있거나 지원이 중단된게 아니므로 스스로 판단해봐야 할 것 같습니다.

<br>

### 6.3.2 let의 위치

---

최상위 함수 스코프에서만 var을 사용하라는 조언을 따르다 보면 다른 선언문에서는 let을 사용해야만 합니다.

선언 키워드는 의사 결정에 영향을 미치지 않습니다. 가장 좋은 방법은 스스로 "이 변수를 최소한으로 노출시키면서 요구 사항을 충족하는 스코프는 어디인가?"라는 질문을 스스로 해보는 겁니다.

질문에 대한 답을 찾으면 변수를 블록 스코프에 위치시킬지, 함수 스코프에 위치시킬지 바로 판단할 수 있습니다. 그런데 처음에 변수를 블록 스코프에 위치시켰는데 나중에 함수 스코프로 올려야 한다는 사실을 알게 되는 경우가 있을 수 있습니다. 그떄는 해당 변수의 선언 위치뿐만 아니라 사용된 선언자 키워드로 변경하면 됩니다.

선언이 블록 스코프에 속해 있다면 let을 사용하고, 함수 스코프에 있다면 var를 사용하라고 저자는 얘기합니다.

<br>

### 6.3.3 catch와 스코프

---

지금까지 var와 매개변수는 함수 스코프이고, let/const는 블록 스코프임을 나타낸다고 배웠습니다. 그런데 한 가지 알아두어야 할 작은 예외가 있습니다. 바로 catch 입니다.

1999년, ES3에 try...catch가 도입된 이후, catch 절에서 선언된 변수는 (잘 알려지지 않은 기능이지만) catch 절 밖에서는 사용할 수 없었습니다.

```js
try {
  doesntExist();
} catch (err) {
  console.log(err);
  // ReferenceError: 'doesntExist' is not defined
  // 예외가 발생한 곳을 알려주는 메시지

  let onlyHere = true;
  var outerVariable = true;
}

console.log(outerVariable); // true

console.log(err);
// ReferenceError: 'err' is not defined
// 또 다른 (발견되지 않은) 예외
```

catch 절로 선언한 err 변수는 해당 블록으로 블록 스코프가 지정됩니다. 이 catch 절 블록은 let을 통해 다른 블록 스코프 선언을 포함할 수 있습니다. 그러나 이 블록 내부의 var 선언은 여전히 외부 함수/글로벌 스코프에 연결됩니다.

ES2019(책의 작성 시점 최신 명세서) 이전에는 catch 절에서 오류 객체를 사용하려면 catch 뒤에 매개변수를 반드시 추가했어야 했는데 ES2019에서는 선택 사항으로 바뀌었습니다. 그런데 catch 블록을 오류 객체 변수 선언 없이 사용하면 catch 블록은 스코프를 형성하지 않고 그냥 블록으로 처리됩니다.

그러니 정상 복구를 위해 예외 처리를 해야 하지만 오륫값 자체는 신경 쓰지 않아도 된다면 catch에 오류 객체 변수 선언을 생략하세요.

```js
try {
  doOptionOne();
} catch {
  // 오류 객체 선언 생략
  doOptionTwoInstead();
}
```

catch에서 오류 객체 변수를 생략하는 패턴은 작은 변화지만 많이 쓰이는 효율적인 단순화 패턴입니다. 이 패턴을 사용하면 불필요한 스코프를 줄여서 약간의 성능 향상을 꾀할 수도 있습니다.

<br>

## 6.4 블록 내 함수 선언

지금까지 let 또는 const를 사용하는 선언은 블록 스코프, var 선언은 함수 스코프가 지정된다는 것을 살펴봤습니다. 그렇다면 블록 안에 직접 함수 선언 방식으로 함수를 정의하면 어떤 일이 생길까요? 블록 내 함수 선언(**Fib**: _function declarations in blocks_)에 대해 알아봅시다.

함수 선언을 var 선언과 동일하다고 생각하는 사람들이 많습니다. 그럼 함수 선언도 var 변수와 같은 스코프 메커니즘을 따를까요?

맞기도 하고, 아니기도 합니다. 혼란스러우니 코드를 보겠습니다.

```js
if (false) {
  function ask() {
    console.log("여기가 실행될까요?");
  }
}

ask();
```

이 프로그램을 실행했을 때 가능한 결과는 세 가지입니다.

1. ask 식별자의 스코프가 if 블록 스코프로 지정되어 외부/전역 스코프에서는 사용할 수 없어 ask() 호출 시 ReferenceError 예외와 함께 호출에 실패
2. ask 식별자가 존재하긴 하지만 if 구문이 실행되지 않아 정의가 이뤄지지 않았기 때문에 ask는 호출 가능한 함수가 아니여서 호출 시 TypeError와 함께 호출 실패
3. 문제없이 호출되어 '여기가 실행될까요?' 출력

JS 명세서에 따르면 블록 내부에 함수 선언을 하면 블록 스코프가 적용되어 1번처럼 작동해야 합니다. 하지만 브라우저 기반 JS 엔진 대부분이 (V8 엔진을 사용하는 Node.js도 포함) 2번처럼 작동합니다. 식별자는 if 블록 외부 스코프로 지정되지만 함숫값이 자동으로 초기화되지 않아 undefined 상태로 남기 때문입니다.

브라우저에서 돌아가는 JS 엔진은 왜 명세서에 반하는 작동을 허용하는 걸까요? ES6에서 블록 스코프가 도입되기 전에 이미 이러한 엔진들은 FiB와 관련된 동작을 지원하고 있는데, ES6 이후 명세서를 준수하기 위해 엔진 동작을 변경하면 기존 웹사이트에서 돌아가는 JS 코드에 문제가 발생할 수 있다는 우려가 있었기 때문입니다. 이런 이유로 브라우저 JS 엔진에 한해 예외를 허용하게 된 겁니다.
