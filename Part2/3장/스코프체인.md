# 스코프체인

스코프와 중첩 스코프 사이에 맺어진 연결을 스코프 체인 (scope chain)이라고 합니다. <br /> 변수 접근 시 사용할 경로가 스코프 체인을 통해 결정됩니다. 이때 체인은 변수 탐색 경로가 위 혹은 바깥으로만 향하도록 지시받습니다.

## 3.1 탐색의 진실

```jsx
// 전역 스코프: 빨간색 버블(1)
const students = [
  { id: 33, name: "성한" },
  { id: 30, name: "기원" },
  { id: 28, name: "성준" },
  { id: 28, name: "민지" },
  { id: 26, name: "서하" },
];

function getStudentName(studentID) {
  // 함수 스코프: 파란색 버블(2)
  for (let student of students) {
    // 반복문 스코프: 초록색 버블(3)
    if (student.id == studentID) {
      return student.name;
    }
  }
}

const nextStudent = getStudent(33);

console.log(nextStudent);
// 성한
```

스코프 버블 그림에서 for 반복문에 있는 변수 참조 students의 색을 확인하면 빨간색 구슬임을 알 수 있습니다.

런타임에 변수에 접근하는 과정을 탐색이라는 개념에 비유해 알아봤습니다. 탐색 과정 중 엔진은 현재 스코프를 관리하는 스코프 매니저에게 알고 있는 식별자 혹은 변수인지 물어보고, 원하는 식별자 혹은 변수를 찾을 때까지 중첩 스코프를 따라 올라가며 전역 스코프를 만날 때까지 탐색을 이어가다가 같은 이름을 가진 변수를 발견하면 즉시 탐색을 중단합니다.

하지만 이 프로세스는 실제 탐색 프로세스와는 다릅니다.

변수가 어떤 스코프에서 왔는지 알려주는 메타 정보는 보통 컴파일 과정 초기에 결정됩니다.
즉, 프로그램이 실행되는 동안 JS 엔진은 변수가 속한 양동이 정보를 이미 알고 있기 때문에 변수가 어떤 양동이에서 왔는지 파악하기 위해 여러 스코프를 탐색할 필요가 없습니다. 런타임에 탐색을 할 필요가 없다는 점은 최적화 관점에서 렉시컬 스코프가 가져다주는 중요한 혜택입니다. 변수 탐색에 시간을 쓰지 않아도 되기 때문에 런타임은 좀 더 효율적으로 작동할 수 있습니다.

하지만 렉시컬 스코프 어디에서도 참조가 불가능한 변수가 있다고 가정해봅시다. (참고로 JS에서 작성한 파일 하나하나는 컴파일 관점에서 독립적인 프로그램입니다).
탐색 과정에서 선언을 찾지 못해도 항상 오류가 발생하는 것은 아닙니다. 런타임에 다른 프로그램이 해당 변수를 전역에 선언했을 가능성도 있기 때문입니다.

다시말해 변수가 선언되었는지의 여부는 컴파일 타임이 아니라, 런타임에 완전히 확정된다고 볼 수 있습니다. 이처럼 탐색이 지연되는 경우는 결국 변수가 발견되는 범위(주로 전역 스코프)를 기준으로 스코프가 정해지고 이는 런타임 중에 변경되지 않습니다.

## 3.2 변수 섀도잉

렉시컬 스코프를 분류하는게 중요해지는 시점은 다음과 같습니다. 두 개 이상의 변수가 있고, 각 변수들이 속한 스코프는 다르지만 이름은 같은 경우입니다.
이름이 같은 두 개 이상의 변순가 하나의 스코프에 있으면 안 됩니다. 이렇게 **복수 참조**가 발생하면 변수가 하나만 있는 것 처럼 처리됩니다.

```jsx
var studentName = "seoha";

function printStudent(studentName) {
  studentName = studentName.toUpperCase();
  console.log(studentName);
}

printStudent("seonghan"); // seonghan

printStudent(studentName); // seoha
```

첫번째 줄에 있는 변수 studentName은 빨간색 구슬, 세 번째 줄에 있는 함수 PrintStudent()의 매개변수 studentName은 파란색 구슬이 됩니다.

그렇다면 할당문 studentName = StudentName.toUpperCase()에 있는 두 studentName과 console.log(studentName)에 있는 studentName은 어떤 색 구슬이 될까요? studentName 참조 세개 모두 파란색 구슬이 됩니다.

우리는 지금까지 탐색이라는 개념을 통해 변수 탐색은 현재 스코프부터 시작해서 바깥과 이를 향해 스코프를 점차 넓혀가며 진행되다가 일치하는 변수를 찾으면 중단되다고 배웠습니다. printStudent("seonghan"); 에서 파란색 studentName을 찾으면 바로 탐색이 중단되는 이유가 바로 이거 때문입니다. 빨간색 구슬은 탐색 범위에 들어오지도 않습니다.

이런 렉시컬 스코프의 주요 특징은 새도잉(shadowing) 이라고 합니다. 예시에서는 파란색 변수 studentName이 만든 그늘에 빨간색 변수 studentName이 가려져 있습니다. 매개변수가 전역 변수를 가려버리는 꼴이 된 거죠. 자 매개변수가 전역 변수를 그늘로 가리고 있다라는 의미에서 그늘진(shadowed)이라는 용어를 이해하면 쉽습니다.

이렇듯 함수에 인수를 넘겨 studentName을 재할당해도 그 영향이 전역 변수에는 미치지 못하고 오직 내부 매개 변수인 studentName에만 미치는 것은 새도잉 때문입니다.

외부 스코프에 존재하는 변수와 같은 이름을 가진 변수를 선언해 새도잉하면, 해당 스코프와 그 안쪽, 아래쪽에 있는 어떤 구슬도 섀도잉된 변수와 같은 색으로 칠할 수 없습니다. 즉 모든 studentName 식별자 참조는 해당 매개변ㅅ누의 변수에 대응할 뿐 전역 studentName변수에 대응하지 않습니다. printStudent() 함수 내부에서 전역 studentName을 참조하는 것은 렉시컬 적으로 불가능합니다ㅣ.

### 3.2.1 전역 언새도잉

지금부터 다룰 내용은 좋은 Practice가 아니고 유용성 측면에서도 한계가 있으며 읽는 사람이 혼란에 빠져 버그를 만들 확률도 높이므로 조심해서 사용하기 바랍니다(by 심슨)

지금까지 배운것과 달리, 전역 변수를 가린 변수가 있는 스코프에서 전역 변수에 접근할 수 있는 방법이 있습니다. 전형적인 렉시컬 식별자 참조를 통해서가 아닌 다른 방법을 통하면 가능합니다.

전역 스코프에서는 Var로 선언한 변수와 function 키워드로 선언한 함수는 전역 객체의 프로퍼티를 통해 접근할 수 있습니다. 전역 객체는 본질적으로 전역 스코프를 객체로 나타낸 것입니다. 브라우저에서 실행되는 JS 코드를 작성해본 경험이 있다면 window객체가 전역 객체라는 것을 알고 있을 겁니다.

```jsx
var studentName = "seoha";

function printStudent(studentName) {
  console.log(studentName);
  console.log(window.studentName);
}

printStudent("seonghan");
// seonghan
// seoha
```

window 참조가 보이나요? 해당 표현식은 전역 변수 studentName을 window 에 있는 프로퍼티처럼 접근하고 있습니다. 그늘을 만든 변수가 있는 스코프에서 그늘로 가려진 변수에 접근할 수 있는 방법은 바로 이렇게 전역 객체를 통하는 방법뿐입니다.

window.studentName은 전역변수 studentName을 거울에 비친 값이지 복제본이 아닙니다. 따라서 코드 한쪽에서 값을 변경하면 다른 쪽 코드에도 변경사항이 반영됩니다. window.studentName을 실제 변수 studentName에 접근하게 해주는 게터, 세터라고 생각하는 사람이 있을 겁니다. 그런데 사실은 전역 객체에 프로퍼티를 만들거나 값을 설정하면 전역 스코프에 변수 추가가 가능합니다.

위에 소개한 방법은 전역 스코프변수에 접근할 때만 작동하고, var, function 키워드를 사용해 선언했을때만 작동합니다.

### 3.2.2 복사는 접근과 다릅니다

```js
var special = 422;

function lookingfor(special) {
  var another = {
    special: special,
  };

  function keepLooking() {
    var special = 3.141592;
    console.log(special);
    console.log(another.special);
    console.log(window.special);
  }

  keepLooking();
}

lookingFor(11);

// 3.141592
// 11
// 422
```

"예시처럼 another 객체를 사용하면 매개변수 special은 keepLooking()안에서 절대 접근 불가능한다는 주장이 틀린거 같아요!" 라는 질문을 할 수 있습니다. 하지만 이것은 여전히 옳습니다.

specil: special은 매개변수 special의 값을 또 다른 컨테이너에 복사해 전달합니다. 별개의 컨테이너에 값을 넣게 되면 당연히 새도잉이 효과를 발휘하지 못합니다. 그런데 새도잉이 효과가 없다는 말이 우리가 매개변수 special에 접근할 때는 객체 프로퍼티라는 별개의 컨테이너를 통해 컨테이너에 복사된 값에 접근한다느 뜻입니다. keepLooking()안에서 매개변수 special에 값을 재할당할수는 없습니다.

"아니면 숫자 11 대신에 객체나 배열 같은걸 쓰면 되지 않을까요" 라고 질문할 수도 있습니다. 원싯값의 복사본 대신 객체 참조를 사용하면 접근 불가능하다는 문제를 고칠 수 있을까요?

아뇨 고칠수 없습니다. 참조 복사본을 통해 객체의 내용을 수정하는 건 렉시컬환경을 고려해 변수 자체에 접근하는 것이 아니기 때문입니다. 객체 참조를 사용한다고 해도 여전히 매개변수 special값을 재할당 할 수는 없습니다.

### 3.2.3 금지된 섀도잉

모든 선언 조합이 섀도잉을 만들어내는 것은 아닙니다. let은 var를 가릴 수 있지만 var는 let을 가릴 수 없습니다.

```js
function something() {
  var special = "자바스크립트";
  {
    let special = 42;
  }
}

function something() {
  let special = "자바스크립트";
  {
    var special = 42; // Syntax Error
  }
}
```

another() 함수 안의 var special은 함수 스코프에 선언을 시도하느데, something 함수에서 볼 수 있는것처럼 그 자체로는 문제가 없습니다.

예시의 구문 오류는 special이 이미 선언되어 있기 때문에 발생했습니다. 새도잉은 일반적으로 잘 허용되기떄문에 something에서는 구문 오류가 발생하지 않습니다.

Syntax Error가 발생한 진짜 이유는 var가 같은 이름을 사용해 let으로 선언한 변수의 경계를 가로지르려고 했기 때문입니다. 이는 허용되지 않습니다.

하지만 경꼐 뛰어넘기 금지는 함수 경계를 만났을 때는 효과를 발휘하지 못하기 때문에 다음 예시는 정상적으로 작동합니다.

```js
function something() {
  var special = "자바스크립트";
  {
    let special = 422;
  }
}

function something() {
  let special = "자바스크립트";

  ajax("https://nemonemo.org", function callback() {
    var special = 422; // Syntax Error
  });
}

요약하자면 내부 스코프에 있는 let은 외부 스코프에 있는 var를 언제나 가릴 수 있지만 내부 스코프에 있는 var는 둘사이에 함수 경계가 있는 경우에만 외부 스코프에 있는 let을 가릴 수 있습니다.
```

## 3.3 함수 이름 스코프

함수 선언문(function declaration)은 아래와 같은 형식을 가집니다.

```js
function hi() {
  // ...
}
```

함수 선언문은 함수를 둘러싸는 스코프에 hi라는 식별자를 생성합니다.

```js
var hi = function () {
  // ...
};
```

예시에서도 마찬가지로 변수 hi가 만들어집니다. 하지만 예시는 함수 표현식(function expression)이기 때문에 함수 자체가 호이스팅 되지 않습니다.

함수 선언문과 함수 표현식의 두드러지는 차이점은 함수 이름 식별자 작동 방식입니다. 기명 함수 표현식 예시를 살펴봅시다.

```js
var hi = function hello() {
  // ...
};
```

우리는 hi가 외부 스코프에 그친다는 것을 이미 알고 있습니다. 그렇다면 식별자 hello는 어떨까요? 일반적인 함수 선언문이었다면 이름 식별자는 외부 혹은 둘러싸는 스코프에 그칠 것이고 기명 함수 표현식도 같지 않을까 생각하기 쉽습니다. 하지만 hello는 함수안에 식별자 그 자체로 선언됩니다.

```js
var hi = function hello() {
  // ...
  console.log(hello);
};

hi(); // function hello()

console.log(hello); // Reference Error: hello is not defined
```

hello는 함수 밖이 아니라 안에 선언되는 것뿐만 아니라 읽기 전용으로 선언됩니다.

```js
var hi = function hello() {
  "use strict";
  hello = 422; // TypeError
};

hi(); // TypeError
```

예시는 엄격모드가 적용되었기 때문에 할당 실패 시 TypeError가 발생합니다. 비엄격 모드에서는 별도의 오류 없이 그냥 할당에 실패합니다.

```js
var hi = function () {
  // ...
};
```

예시는 이름 식별자 없이 함수 표현식을 사용할 때 입니다. 이름 식별자가 있는 함수 표현식은 "기명 함수 표현식"이라고 부르는데,
예시처럼 이름 식별자가 없는 경우에는 "익명 함수 표현식" 이라고 합니다. 익명 함수 표현식은 보다시피 스코프에 영향을 미치는 이름 식별자가 없습니다.

## 3.4 화살표 함수

ES6에서는 언어 차원에서 함수 표현식을 만들 수 있는 새로운 방법인 화살표 함수(Arrow function)이 도입되었습니다.

```js
var hi = () => {
  // ...
};
```

화살표 함수를 정의할 때는 function 키워드를 쓸 필요가 없습니다. 매개변수 리스트를 감싸는 ()또 때에 따라 생략이 가능합니다. 마찬가지로 함수 본문을 감싸는 {} 역시 경우에 따라 생략할 수 있습니다. {}를 생략한 경우에는 return 키워드 없이도 값을 반환할 수 있습니다.

화살표 함수는 렉시컬 스코프 관점에서 익명으로 취급됩니다. 화살표 함수는 함수를 참조하는 연관 식별자와 직접 연결되어 있지 않습니다. hi에 할당을 하면 다음 예시처럼 hi라는 이름이 자체적으로 추론되긴 하지만 기명 함수와 똑같이 작동하는 것은 아닙니다.

```js
var hi = () => {
  // ...
};

hi.name; // hi
```

```js
() => 422;

(id) => id.toUpperCase();

(id, name) => ({ id, name });

(...args) => {
  return args[args.length - 1];
};
```

화살표 함수는 개발자에게 다양한 형태나 조건에 대한 유추를 비용으로 떠넘기면서 그 간결성을 유지합니다.

화살표 함수는 익명이라는 특성(그리고 명확한 형식이 없다는 특성) 이외에는 function을 사용해 선언한 함수와 동일 렉시컬 스코프 규칙을 적용받습니다. 함수 본문을 감싸는 대괄호가 있든 없든 화살표 함수는 별도의 내부 중첩 스코프를 형성하는데, 이 중첩 스코프에 선언된 변수는 일반 함수의 본문 내에 선언한 변수 스코프와 동일하게 작동합니다.

## 3. 5 정리

선언을 하든 표현식을 쓰든, 함수를 정의하면 새로운 스코프가 만들어집니다. 스코프 중첩을 어떻게 만들었는지에 따라 스코프의 계층관계가 생성되는데, 이를 스코프 체인이라고 부릅니다. 스코프 체인은 변수를 위 혹은 바깥쪽 방향으로만 접근 가능하도록 통제합니다.

새 스코프가 생기면 변수를 넣을 새로운 공간이 만들어집니다. 스코프 체인 내, 다른 계층에 있는 스코프에 이름이 같은 변수가 있으면 섀도잉 때문에 바깥 스코프에 있는 변수에 접근할 수 없게 됩니다.
