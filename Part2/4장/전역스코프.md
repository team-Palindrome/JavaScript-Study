# 전역스코프

## 4.1 전역 스코프를 배워야 하는 이유

JS 파일 여러개가 모여 애플리케이션이 만들어집니다. 그렇다면 JS엔진은 어떻게 분리된 여러 개의 파일을 실행 시점에 하나로 연결 시키는 걸까요?

브라우저에서 실행되는 애플리케이션은 주로 세가지 방법으로 파일을 하나로 모읍니다.

1. ES 모듈을 바로 사용하는 경우에는 파일을 각자 하나씩 로딩합니다. 로딩 후에는 import 문에 있는 다른 모듈을 참조합니다. 이때 각 모듈은 서로의 스코프를 공유하지 않고 배타적으로 협력합니다.

2. 구축 과정에 번들러가 관여하는 경우에는 파일 전체가 합쳐져서 브라우저와 JS엔진에 전달됩니다. 따라서 브라우저, JS엔진운 하나의 커다란 파일만 처리합니다. 그런데 이렇게 애플리케이션 하나가 단일 파일에 모여 있는 경우라도 파일 내 코드 조각 일부에서 다른 코드 조각을 참조할 때 사용할 이름을 등록한다든가 타 코드 조각에 접근할 때 적용할 메커니즘이 필요합니다.

번들러는 다양한 빌드 환경을 설정할 수 있도록 하는데, 그 중 일부는 파일 내용 전체를 래퍼 함수나 유니버설 모듈을 사용해 하나의 스코프안에 묶도록 도와줍니다. 이때 각 코드 조각은 다음 예시처럼 다른 코드 조각에서 자신을 접근할 수 있도록 하는 지역 변수를 공유 스코프 안에 스스로 등록합니다.

```js
(function wrappingOuterScope() {
  var moduleOne = (function one() {
    // ..
  })();

  var moduleTwo = (function two() {
    // ..

    function callModuleOne() {
      moduleOne.someMethod();
    }

    // ..
  })();
})();
```

보다시피 함수 wrappingOuterScope() 스코프 안에 지역 변수로 선언된 moduleOne과 moduleTwo는 두 코드 조각끼리 협력할 목적으로 선언되었습니다.
wrappingOuterScope()의 스코프는 환경 전체를 아우르는 전역 스코프가 아닌 함수 스코프이긴 하지만 애플리케이션 전체를 아우르는 스코프처럼 작동합니다. 진짜 전역 스코프가 아니지만 wrappingOuterScope()의 스코프에는 모든 최상위 레벨의 식별자가 저장됩니다. wrappingOuterScope()의 스코프는 전역 스코프의 대들보 역할을 한다고 볼 수 있습니다.

3. 마지막 방법은 전역 스코프를 사용하는 방법입니다. 번들러를 사용하든, 파일을 `<script>` 태그를 사용하거나 동적으로 리소스를 로딩해 단순히 브러우저에 개별적으로 불러오든 상관없이 모든 코드 조각을 아우른 하나의 스코프가 없는 경우라면 코드 조각들이 협업할 수 있는 유일한 방법은 전역 스코프를 통해서입니다.

```js
var moduleOne = (function one() {
  // ..
})();
var moduleTwo = (function two() {
  // ..

  function callModuleOne() {
    moduleOne.someMethod();
  }

  // ..
})();
```

세번째 방법을 활용할 때의 번들러 결과 코드는 대게 위와 같습니다.

moduleOne, moduleTwo는 전역 스코프로 던져지고 이 둘을 감싸는 함수 스코프는 없는 것을 확인할 수 있습니다. 그런데 이 상황은 다음 예시처럼 파일이 두개 있고, 프로그램 실행을 위해 파일을 각각 로딩해야 하는 상황과 같습니다.

module1.js의 코드는 아래와 같습니다.

```js
var moduleOne = (function one() {
  // ..
})();
```

module2.js의 코드는 아래와 같습니다.

```js
var moduleTwo = (function two() {
  // ..

  function callModuleOne() {
    moduleOne.someMethod();
  }

  // ..
})();
```

브라우저 환경에서 독립된 .js파일 여러개를 불러와야 하는 상황입니다. 이 경우, 개별 파일이 공유하는 유일한 리소스는 전역 스코프이므로 각 파일의 최상위 스코프에 선언된 변수들은 전역 스코프의 전역 변수과 됩니다.

전역 스코프는 런타임에 프로그램을 구성하는 코드 조각들이 어디에 있는지, 그리고 각 코드 조각이 어떤 방식으로 다른 코드 조각에 접근해 협력하는지에 관여하는 것뿐만 아니라 다음의 경우에도 사용합니다.

- JS 내장 기능을 사용할 때
  원싯값: undefined, null, Infinity, NaN
  네이티브 객체: Date(), Object(), String(), etc.
  전역 함수: eval(), parseInt(), etc.
  네임스페이스: Math, Atomics, JSON
  JS 협력 관계 기술: Intl, WebAssembly

- 특정 호스팅 환경에서 제공하는 내장 기능을 사용할 때
  콘솔 console (and its methods)
  DOM (window, document, etc)
  타이머 timers (setTimeout(..), etc)
  웹 API: navigator, history, geolocation, WebRTC, etc.

변수를 전역에 때려 넣으면 안된다는 것은 거의 모든 개발자들이 동의할 겁니다. 변수 전체를 전역 스코프에 선언하는 건 버그가 발생하길 기도하는 것과 다름없습니다. 하지만 모든 JS 프로그램이 전역 스코프를 접착제 삼아 파일을 모으고 실행한다는 사실은 부인할 수 없습니다.

## 4.2 전역 스코프의 위치

전역 스코프는 함수나 블록 안이 아닌 파일 가장 바깥쪽에 위치한다고 생각할 수 있는데, 실상은 그리 간단하지 않습니다.

### 4.2.1 브라우저의 창 window 객체

전역 스코프가 처리되는 환경 중 가장 순수한 환경은 브라우저에서 단독으로 .js 파일을 로드할 때 관찰 할 수 있습니다. 파일을 로드할 때 브라우저가 자동으로 추가하는게 없어서 "순수"라는 단어를 사용한 것은 아닙니다. 파일 로드 시 많은 것이 추가될 수 있습니다. 하지만 브라우저는 코드 침입을 최소하하고, 전역 스코프가 작동할 때 간섭도 최대한 하지 않습니다.

```js
var studentName = "기원";

function hello() {
  console.log(`Hello, ${studentName}!`);
}

hello();
// Hello, 기원!
```

`<script>`태그 안에 코드를 넣거나, 마크업 안에 `<script src = ...>`로 코드를 연결, 혹은 태그에 대응하는 DOM요소를 동적으로 생성하면, 이 JS 코드를 브라우저 환경에 불러올 수 있습닏. 세 경우 모두 식별자 studentName과 hello가 전역 스코프에 선언됩니다.

식별자가 전역 스코프에 선언된다는 말은 전역 객체의 프로퍼티를 통해 해당 식별자에 접근할 수 있다는 말과 같습니다.

```js
var studentName = "기원";

function hello() {
  console.log(`Hello, ${window.studentName}!`);
}

window.hello();
// Hello, 기원!
```

JS 명세서를 읽어보면 예시에서 외부 스코프가 글로벌 스코프이고 studentName은 전역 변수가 된다는 사실이 당연하다는 걸 알 수 있습니다.

순수라는 단어를 쓴 것은 바로 이런 이유 때문입니다. 그런데 불행하게도 이런 작동 방식이 모든 JS 호스트 환경에서 보장되는 것은 아닙니다. JS 개발자들이 예상치 않은 결과에 종종 놀라는 이유가 바로 여기 있습니다.

### 전역을 가리는 전역

3장에서 본 섀도잉과 전역 섀도잉을 다시 떠올려 봅시다. 안쪽 스코프에 선언된 변수는 바깥쪽 스코프에 선언된 이름이 같은 변수를 가리고 접근을 막습니다.

그런데 전역 변수와 이와 이름이 같은 전역 프로퍼티는 섀도잉과 다른 방식으로 작동합니다. 전역 스코프에서는 다음 예시처럼 전역 객체의 프로퍼티가 전역 변수이 의해 가려집니다.

```js
window.something = 422;

let something = "alswla";

console.log(something);
// alswla

console.log(window.something);
// 422
```

let으로 변수 something을 선언하면 전역 변수가 추가되지만 전역 객체의 프로퍼티가 추가 되지는 않습니다. 그 영향으로 something 렉시컬 식별자가 something전역 객체 프로퍼티를 가리게 됩니다. <br /> 전역 객체에 있는 프로퍼티와 전역 스코프에 등록된 식별자가 다르게 작동하도록 코드를 작성하는 건 좋지 않습니다. 나중에 코드를 읽게 될 사람이 분명 실수하게 될 것입니다.

전역에 무언가를 선언할 때 실수를 막을 수 있는 가장 좋은 방법은 전역에서는 항상 var를 쓰는 것입니다. let과 const는 블록 스코프에서만 쓰고 말이죠.

### DOM 전역 변수

앞서 저는(심슨)은 다양한 JS 호스트 환경 중 브라우저가 전역 스코프 처리 관점에서 가장 순수한 환경이라고 주장했습니다. 그런데 사실 브라우저는 완전히 순수한 환경이 아닙니다. <br /> 브라우저에서 돌아가는 JS 프로그램을 다뤄보면 알겠지만, DOM 요소에 id 속성을 추가하면 전역 변수가 자동으로 생기게 되고, 이 변수를 통해 해당 DOM 요소에 접근할 수 있습니다.

먼저 예시로 사용할 마크업 파일을 봅시다.

```js
<ul id="my-todo-list">
  <li id="first">다이어트</li>
  ..
</ul>
```

그리고 다음 JS파일을 페이지에 연동했다고 가정합니다.

```js
first;
// <li id="first">..</li>

window["my-todo-list"];
// <ul id="my-todo-list">..</ul>
```

DOM id 속성값이 유효한 렉시컬 이름인 경우에는 새로운 렉시컬 변수가 생성되면서 전역 변수를 통해 해당 DOM에 접근할 수 있습니다. id 속성값이 유효하지 않은 렉시컬 이름이면, 오직 전역 객체를 통해서만 DOM 요소에 접근 가능합니다.

이런 식으로 id 속성이 있는 DOM요소에 대응하는 변수를 자동으로 전역에 등록하는 것은 브라우저 환경에서 오래전부터 지원하던 기능입니다. 레거시를 개선할 수 있게지만, 여전히 레거시 기능을 지원하는 이유는 만들어진 지 오래된 사이트 중 자동 변수 등록에 의존하는 경우가 많기 때문입니다. 여러분은 자동으로 등록된 전역 변수는 되도록 사용하지 마세요

### window.name의 정체

```js
var name = 422;

console.log(name, typeof name);
// "422" string
```

예시와는 별개로 window.name은 브라우저가 전역에 미리 정의해놓은 전역 객체의 프로퍼티인데, 언뜻보면 이 프로퍼티는 전역 변수처럼 작동한다고 생각할 수 있습니다. 하지만 일반 전역 변수와는 다르게 작동합니다.

예시처럼 var를 사용해서 전역에 변수를 선언하면 이미 선언되어 있는 전역 객체 프로퍼티 name을 가리지는 않습니다. 전역 스코프에 name이라는 이름을 가진 프로퍼티가 있기 때문에 var는 무시되고 숫자 422는 window.name의 값이 됩니다. 참고로 앞서 논의 했듯이 let name으로 변수를 선언했다면 별도의 전역 변수 name이 생기면서 window.name은 가려졌을 겁니다.

그런데 분명 name에 숫자 422을 할당했는데도 값을 읽으면 문자열 "422"가 튀어나옵니다. 이렇게 브라우저가 이상하게 작동하는 이유는 name 프로퍼티는 사전에 정의된 getter, setter이기 때문입니다. 그리고 setter에는 어떤 값이든 문자열로 변환시키는 규칙이 있고요.

### 4.2.2 웹 워커

웹워커는 브라우저에서 돌아가는 JS의 작동 방식을 바꿔주는 웹 플랫폼 확장기능입니다. JS파일을 별도의 스레드에서 돌아가게 해줍니다.

웹 워커를 사용하는 프로그램은 별도의 스레드에서 실행되므로 레이스 컨디션이나 기타 경쟁 상태를 막거나 피하려는 목적으로 메인 애플리케이션 스레드와 통신이 제한됩니다.

웹 워커는 완전히 별개의 프로그램으로 취급되므로 메인 JS프로그램과 전역 스코프를 공유하지 않습니다. 하지만 코드를 실행하는 건 브라우저의 JS엔진이므로 웹 워커에도 순수 전역 스코프 메커니즘이 적용되느 않을까하는 기대를 할 수 있습니다. 하지만 웹 워커에서는 DOM에 접근할 수 없으므로 전역 스코프에 접근할 수 있게 하는 window를 사용하지 못합니다.

웹 워커에서 전역 객체에 접근하려면 일반적으로 self 키워드를 사용합니다.

```js
var studentName = "민지";
let studentID = 11;

function hello() {
  console.log(`Hello, ${self.studentName}!`);
}

self.hello();
// Hello, 민지!

self.studentID;
// undefined
```

메인 JS 프로그램과 마찬가지로 var와 function 선언은 self처럼 전역 객체에 미러링 프로퍼티를 생성하지만, let을 비롯한 그 이외의 선언은 미러링 프로퍼티를 생성하지 않습니다.

웹 워커 예시처럼 전역 스코프는 일반 JS프로그램의 전역 스코프와 작동 방식이 거의 같습니다. DOM과 엮일 일이 없으므로 훨씬 더 순수하게 작동한다 말할 수 있겠니요.

### 4.2.3 개발자 도구와 콘솔 REPL

개발자 도구는 JS환경을 완전히 재현하지 않습니다. 개발자 도구는 JS코드를 처리하지만 DX라 부르는 개발자 경험을 향상시키기 위해 UX가 설계되었습니다.

DX를 중시하며 일반 JS 프로그램을 처리할 때 보다, 덜 엄격하게 JS 코드 조각을 처리하다 보면 눈에 띄는 차이가 보입니다. 일반 JS 프로그램이었다면 오류가 났을 코드도 개발자 도구에서 입력하면 오류가 나지 않는 식으로요.

이러한 차이 중 스코프와 연관된 사례는 다음과 같습니다.

- 전역 스코프의 작동 방식
- 호이스팅
- 가장 바깥 스코프에서 블록 스코프를 선언을 할 때

콘솔이나 REPL을 사용해 가장 바깥 스코프에 문을 입력하면, 해당 문이 실제 전역 스코프에서 처리되는 것처럼 보이지만 실제로는 그렇지 않습니다. 콘솔, REPL은 전역 스코프 작동 방식을 유사하게 모방하며 입력받은 문을 처리합니다. 그런데 이들은 에뮬레이터일 뿐이라서 JS엔진에서 전역 스코프가 작동하는 방식을 완벽히 모방하지 못합니다. 개발자 도구, 콘솔, REPL은 개발자 편의를 우선시합니다. 이 말은 JS명세서와는 다르게 프로그램이 동작할 수 있다는 겁니다.

개발자 도구는 개발자 편의를 위한 도구이므로 개발자 활동에 최적화되어있지만 실제 JS 프로그램 컨텍스트 결졍 혹은 검증하려는 목적으로 쓰기에는 적합하지 않다는 점을 알아주세요.

### 4.2.4 ES 모듈

모듈 패턴은 ES6에서 공식 지원하기 시작했습니다. 이 특징은 파일 내 최상위 레벨 스코프 작동 방식입니다.

```js
var studentName = "hong";

function hello() {
    console.log(`Hello, ${ studentName }!`);
}

hello();
// Hello, hong!

export hello;
```

import를 사용해 예시 코드를 ES모듈 형태로 불러와 사용하는 경우에도 그냥 단독 파일을 실행하는 것과 동일하게 동작합니다. 하지만 전체 애플리케이션 관점에서 관찰되는 현상은 경우가 다릅니다.

studentName과 hello는 모듈 내에서는 최상위 레벨인 가장 바깥 스코프에서 선언되지만, 저역 변수가 되지는 않습니다. 대신 모듈 범위 스코프의 변수가 됩니다. 참고로 모듈 범위 스코프는 모듈 전역스코프라고도 합니다.

그런데 모듈에서는 최상위 레벨의 선언을 프로퍼티로 추가할 수 있는 모듈 범위 스코프 객체를 지원하지 않습니다. 그렇다고 모듈로 구성된 프로그램에 전역 변수가 없다거나 전역 변수에 접근할 수 없다는 것이 아니라 모듈 내 최상위 레벨에서 변수를 선언하면 전역 변수가 생기지 않는 다는 의미입니다.

모듈 최상위 레벨 스코프에서는 모듈 내 모든 콘텐츠가 함수에 래핑된 것처럼 묶여서 처리되고, 이 묶음은 전역 스코프의 하위 스코프가 됩니다.

ES모듈 패턴에서는 현재 모듈을 작동시키는데 필요한 모든 모듈을 import하는 전역 스코프에 대한 의존도를 최소화하라 권장합니다. 따라서 ES 모듈 패턴을 사용하면 전역 스코프나 전역 스코프 객체를 사용하는 빈도가 줄어듭니다.

### 4.2.5 Node.js

Node.js는 개발자를 당황하게 만드는 몇 가지 특성이 있습니다.
엔트리 파일을 포함하여 모든 JS파일을 모듈로 처리한다는 특성이 그 중 하나입니다. 이런 특징은 브라우저에서 모듈이 아닌 파일을 로드할 때와 다르게 각 JS 파일이 자체 스코프를 갖게합니다.

필자가 이 책을 집필하는 시점에는 Node.js가 ES 모듈을 지원한다고 발표했지만, 사실 Node.js는 태생부터 Common.js라는 모듈 형식을 지원했습니다.

```js
var studentName = "성준";

function hello() {
  console.log(`Hello, ${studentName}!`);
}

hello();
// Hello, 성준!

module.exports.hello = hello;
```

코드를 함수로 감싸는데, 이는 var 및 function 선언이 전역 변수로 취급되는 걸 방지하고 선언들을 함수 스코프에 포함시키기 위해서입니다.

```js
function Module(module,require,__dirname,...) {
    var studentName = "성준";

    function hello() {
        console.log(`Hello, ${ studentName }!`);
    }

    hello();
    // Hello, 성준!

    module.exports.hello = hello;
}
```

Node.js는 추가 함수 Module()을 호출해 모듈을 실행합니다. 예시를 보면 Node.js에서 var 및 function 선언문이 왜 전역이 아니고 모듈 스코프인지 명쾌해집니다.

이런 API의 식별자들은 전역에 있지 않습니다. 이 API들은 예시에서 함수 Module()에 있는 매개변수처럼 모든 모듈의 스코프에 자동으로 주입됩니다.

그렇다면 Node.js에서 진짜 전역 변수는 어떻게 정의될까요? Node.js 내장 전역 프로퍼티인 global에 프로퍼티를 추가하는 방법이 유일합니다. global은 진짜 전역 스코프 객체에 접근할 수 있게 해주는 참조값으로 브라우저 환경의 window와 비슷합니다.

```js
global.studentName = "hong";

function hello() {
  console.log(`Hello, ${studentName}!`);
}

hello();
// Hello, hong!

module.exports.hello = hello;
```

studentName을 객체 global의 프로퍼티로 추가하고, console.log() 문안에서 studentName을 일반 전역 변수를 사용하는 것처럼 접근했습니다.

식별자 global은 JS가 아닌 Node.js에 정의되었다는 걸 기억하세요.

## 4.3 GlobalThis

호스팅 환경마다 차이를 보이는 특징을 정리하면

- 최상위 레벨 스코프에 var, function 또는 let, const, class를 사용해 전역 변수를 선언할 수 있는데 두 방식에는 차이가 있습니다.
- var, function 을 사용해 선언하면 해당 선언은 전역 객체의 프로퍼티로 추가됩니다.
- 전역 스코프 객체는 window, self, global로 참조합니다.

전역 스코프 객체 참조를 얻는 다른 방법을 살펴봅시다.

```js
const theGlobalScopeObject = new Function("return this")();
```

new Function()을 사용한 방법도 있습니다.

방법은 더 많지만 모든 방법을 설명하지 않는 이유가 있습니다.

ES2020에서 마침내 전역 스코프 객체 참조가 globalThis로 표준화 되었기 때문입니다. 코드를 실행하는 JS 엔진 상태에 따라 다르지만 요즘에는 globalThis를 사용하면 전역 스코프 객체를 참조할 수 있습니다.

JS 환경이 globalThis를 지원하지 않는다면 다음과 같은 폴리필을 사용해 호스트 환경에 상관없이 안전한 방식으로 전역 스코프 객체를 참조할 수 있습니다.

```js
const theGlobalScopeObject =
  typeof globalThis != "undefined"
    ? globalThis
    : typeof global != "undefined"
    ? global
    : typeof window != "undefined"
    ? window
    : typeof self != "undefined"
    ? self
    : new Function("return this")();
```

## 4.4 정리

코드를 모듈 단위로 쪼개는 개발 방식이 자리 잡으면서 전역 네임스페이스에 식별자를 저장하는 방식을 지금은 많이 사용하지 않습니다. 그럼에도 불구하고 전역 스코프는 모든 JS 프로그램에 존재하고 중요한 역할을 합니다.

여러분이 작성한 코드가 브라우저를 넘어, 점어 그 영역을 확애해 감에 따라서 호스트 환경별로 전역 스코프와 전역 스코프 객체가 어떤 차이를 보이는지 확실히 아는 것이 중요해졌습니다.
