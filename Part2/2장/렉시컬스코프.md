# 렉시컬 스코프

컴파일레이션 중 스코프가 결정되는 방식과 이를 “렉시컬 스코프” 라 부른다. 작업 중인 프로그램이 어떻게 작동하는지 제대로 알고 싶다면 스코프의 작동 원리를 정확히 이해해야 한다.

### 2.1 구슬과 양동이

스코프를 효과적으로 이해하기 위해 여러 색이 있는 구슬을 같은 색의 양동이에 분류하는 작업에 비유한다면.

빨간색, 파란색, 초록색으로만 구성된 구슬 한 더미가 있다고 상상해보자. 이제 이 구슬을 같은 색끼리 모으고 빨간색 구슬은 빨간색 양동이에, 파란색 구슬은 파란색 양동이에, 초록색 구슬은 초록색 양동이에 넣겠다고 해보자. 이렇게 구슬을 분류해놓으면 초록색 구슬이 필요할 때 초록색 양동이로 가면 얻을 수 있다는 것을 예상할 수 있다.

여기서 구슬은 프로그램 내 변수이다. 그리고 양동이는 스코프(함수 혹은 블록) 이다. 양동이에 칠한 색은 각 스코프를 의미한다. 변수의 스코프는 변수가 어디에서 선언되었는지에 따라 달라지기 때문에 각 구슬의 색은 원래 구슬이 어디에서 생성되었는지에 따라 결정된다.

```jsx
// 외부/전역 스코프: 빨간색 버블(1)
var students = [
	{ id: 45, name: "성한" }
	{ id: 73, name: "기원" }
	{ id: 112, name: "성준" }
	{ id: 7, name: "민지" }
];

function getStudentName(studentID) {
	// 함수 스코프: 파란색 버블(2)
	for (let student of students) {
		// 반복문 스코프: 초록색 버블(3)
		if (student.id == studentID) {
			return student.name;
		}
	}
}

var nextStudent = getStudent(112);

console.log(nextStudent);
// 성준
```

제일 큰 버블은 1번 빨간색 양동이, 그 다음 큰 버블은 2번 파란색 양동이, 가장 작은 버블은 3번 초록색 양동이 라고 생각하면 된다.

스코프 버블은 함수/블록 스코프가 어디에 있느냐에 따라 컴파일 중에 결정되는데 (3)번 버블이 (2)번 버블에, (2)번 버블이 (1)번 버블에 속하는 것처럼 스코프 블록은 서로 중첩이 가능하다. 다만 스코프 버블은 부모 스코프 버블에 온전히 포함되기 때문에 한 스코프가 두 개의 바깥 스코프에 동시에 포함되는 일은 절대 일어나지 않는다.

각 구슬(변수나 식별자)은 어떤 버블(양동이) 에서 정의되었느냐에 따라 색이 결정되며, 어디에서 접근 가능한지에 따라 결정되는건 아니다.

JS 엔진은 컴파일 중에 프로그램을 처리하기 때문에 변수가 선언된 곳을 찾는다는 건 내가 지금 속한 스코프가 무슨색이냐 질문하는 것과 같다.

파란색 양동이 (버블2) 는 초록색 양동이 (버블3)를 완전히 감싸고 있고, 빨간색 양동이 (버블1) 역시 파란색 양동이 (버블2) 를 완전히 감싸고 있다. 이렇게 스코프는 프로그램의 필요에 따라 원하는 대로 중첩해 사용 가능하다.

이미 선언된 변수나 식별자를 참조(비선언) 할 때는 현재 스코프나 현재 스코프의 위, 혹은 바깥 스코프에 참조하려는 변수나 식별자가 있는 경우 가능하지만, 정의가 아래 혹은 안쪽 스코프에 있으면 불가능하다.

(버블 1)에 있는 표현식은 빨간색 구슬에만 접근할 수 있고, 아래 안쪽 스코프인 파란색 양동이, 초록색 양동이에 있는 구슬에는 접근할 수 없다. 반면 (버블 3) 에 있는 표현식은 바로 위 스코프인 파란색 양동이, 빨간색 양동이에 있는 구슬 모두에 접근 가능하다.

런타임 중에 이런 비선언 구슬 색을 결정짓는 절차를 탐색으로 개념화할 수 있다. `for` 반복문에서 참조하고 있는 변수 `students` 는 선언이 아니기 때문에 색이 없다. 따라서 (버블 2) 스코프에서 이름이 `students` 인 구슬을 찾게 되는데, 파란색 양동이에는 조건에 맞는 구슬이 없기 때문에 다음 바깥/위 스코프인 (버블 1)로 영역을 확장해 원하는 구슬이 있는지 검색한다.

그런데 (버블 1) 에는 이름이 `students` 인 구슬이 있으므로 `for` 반복문에 있는 변수 `students` 는 (버블 1)에 있는 구슬을 참조하게 된다.

`if (student.id == studentID)` 문에서 (버블 3)에 있는 구슬 student와 (버블2)에 있는 구슬 `studentID` 역시 같은 방식으로 무엇을 참조할지가 결정된다.

### 정리

- 변수는 특정 스코프에서 선언된다. 이때 변수는 다양한 색의 구슬이고, 구슬은 같은 색 양동이에 담긴다.
- 선언이 이뤄진 스코프와 동일한 스코프에 있는 변수 참조, 혹은 선언이 이뤄진 스코프보다 더 깊은 스코프에 있는 변수 참조는 해당 스코프와 동일한 색을 가진 구슬이 된다. 그런데 중간에 있는 스코프가 변수 선언을 섀동이 하면 이런 규칙이 적용되지 않는다.
- 양동이 색과 양동이에 어떤 구슬이 담길지는 컴파일 중에 결정된다. 이렇게 컴파일레이션 과정에서 확정된 정보는 프로그램 실행 중에 변수(구슬 색)을 탐색하는데 사용한다.

<br>

## 2.2 JS 엔진 구성원 간의 대화

- 엔진: 컴파일레이션을 시작부터 끝까지 책임지고 JS로 만든 프로그램을 실행함
- 컴파일러: 엔진의 친구로, 파싱과 코드 생성 과정에서 일어나는 모든 잡일을 담당함
- 스코프 매니저: 엔진의 또다른 친구로, 선언된 모든 변수와 식별자를 담은 탐색용 목록을 작성하고 유지보수함. 여기에 더해 코드 실행 시, 선언된 변수와 식별자 접근 관련 규칙을 강제함

```jsx
var students = [
	{ id: 45, name: "성한" }
	{ id: 73, name: "기원" }
	{ id: 112, name: "성준" }
	{ id: 7, name: "민지" }
];

function getStudentName(studentID) {
	for (let student of students) {
		if (student.id == studentID) {
			return student.name;
		}
	}
}

var nextStudent = getStudent(112);

console.log(nextStudent);
// 성준
```

첫 줄부터 이어지는 줄에 있는 배열(추후 할당 현산자를 통해 `students`에 할당됨)과 그 안의 요소들은 JS 리터럴(스코프의 영향을 받지 않음) 이기 때문에 여기서는 `var`를 통한 선언 (`var students = [ … ]`) 과 초기화 및 할당에 집중해 살펴보자.

변수를 선언하고, 배열 리터럴을 해당 변수에 할당하는 코드를 봤을 때 일반적으로 이를 하나의 문이라 생각한다. 실제로 JS는 이를 컴파일 중에 컴파일러가 처리하는 작업과 실행 중에 엔진이 처리하는 작업, 두 개의 별도 작업으로 나눠 해당 문을 처리한다.

`var students = [ … ]` 를 보면 보통 문이 하나 있다고 생각하는데, JS 엔진은 그렇지 않다고 한다.

컴파일러가 개발자가 작성한 소스 코드를 받아 엔진이 최종적으로 실행할 코드를 생성할 때는 생각보다 고려해야 할 세부 사항이 많다. `var students = [ … ]` 에 대한 코드를 생성할 때는 “배열이 저장될 메모리 공간을 할당하고, `students` 라는 이름표를 메모리 공간에 연결한다” 정도로 생각할 수 있는데 사실 이 과정이 전부가 아니다.

실제 컴파일러가 `var students = [ … ]` 를 처리할 때 거치는 단계는 다음과 같다.

1. 컴파일러는 var students를 만나면 스코프 매니저에 특정 스코프 양동이에 students 라는 일므을 가진 변수가 있냐고 물어본다. 스코프 매니저가 그렇다고 하면 컴파일러는 선언을 무시하고 지나간다. 그렇지 않다고 하면 컴파일러는 프로그램이 실행될 때 스코프 매니저에게 해당 스코프 양동이에 students라는 이름의 변수를 생성해달라고 요청한다.
2. 컴파일러는 프로그램 실행 시점에 엔진이 실행할 students = [] 할당문에 대한 코드를 생성한다. 엔진은 추후 실행 시점에 컴파일러가 생성한 코드를 보고 스코프 매니저에게 현재 스코프 양동이에 students 라는 이름을 가진 변수가 있냐고 물어본다. 없다고 하면 상위 스코프로 타고 올라가며 students 변수를 찾는다. 찾으면 엔진은 여기에 배열([ … ])의 참조를 할당한다.

### 요약하면

1. 컴파일러는 스코프 변수 선언을 준비한다(현재 스코프에서 스코프 변수가 선언되어 있지 않은 경우)
2. 엔진은 엔진이 실행되는 동안, 문에서 할당 부분을 처리하기 위해 스코프 매니저에게 변수를 찾아달라고 부탁하고 변수를 undefined로 초기화해 사용할 준비를한다. 그 이후 변수에 배열을 할당한다.

<br>

## 2.3 중첩 스코프

함수 `getStudentName()` 을 실행할 때가 되면 엔진은 함수 스코프 인스턴스를 만들어달라고 스코프 매니저에게 부탁한다. 그럼 스코프 매니저는 인수 112를 할당할 매개변수(`studentID`)를 찾는 등의 일을 이어서 수행한다.

`getStudentName()` 용 함수 스코프는 전역 스코프 안에 중첩되어 있다. `for` 반복문을 위한 블록 스코프 역시 유사하게 함수 스코프 안에 중첩되어 있다.

모든 스코프는 한 번이든 여러 번이든 실행될 때마다 스코프에 해당하는 스코프 매니저 인스턴스를 갖게 된다. 그리고 스코프가 실행될 때마다 자동으로 해당 스코프 내 모든 식별자가 스코프에 등록된다. (이를 변수 호이스팅 이라고 한다)

스코프 시작 부분에서 식별자가 function 선언과 함꼐 등장했다면 해당 변수는 연관된 함수 참조로 자동 초기화된다. 그리고 식별자가 `let`, `const` 가 아닌 `var` 선언과 함께 등장한 경우, 해당 변수는 자동으로 `undefined` 로 초기화되어 바로 사용 가능한 상태가 된다. `var` 로 선언하지 않은 변수는 초기화 되지 않은 상태 (TDZ)가 되어 엔진에 의해 선언 및 초기화가 완전히 끝날 때 까지 사용할 수 없다.

`for (let student of students) {` 문에서 `students`는 검색이 꼭 필요한 소스 참조이다. 그런데 함수 스코프에는 `students` 가 없다. 이런 상태에서 엔진은 `students` 를 어떻게 찾을까?

렉시컬 스코프의 중요한 특징 중 하나는 **현재 스코프에서 식별자 참조를 찾을 수 없을 때 해당 스코프를 감싸는 바깥 스코프에서 식별자 참조를 찾는다는 것**이다. 이런 프로세스는 원하는 식별자 참조를 찾거나 더 이상 찾을 만한 스코프가 없을 때 까지 계속 된다.

<br>

### 2.3.1 탐색이 실패할 경우

엔진이 탐색 범위를 확장해가며 모든 렉시컬 스코프를 뒤졌는데도 원하는 식별자를 찾지 못한다면 오류 발생 상태가 조성된다. (엄격 모드인지 아닌지에 따라 오류가 달리 처리된다)

<br>

### **undefined에 관한 혼란**

변수가 소스 역할을 할 때 식별자를 찾지 못하면 해당 변수는 선언되지 않은 변수로 간주되어 `ReferenceError`가 발생한다. 변수가 타깃역할을 하고 프로그램이 엄격 모드에서 실행되고 있을 때 역시 해당 변수는 선언되지 않은 변수로 간주되어 소스 역할 변수를 못찾을때와 유사하게 `ReferenceError` 가 발생한다.

대부분의 JS 실행 환경에서 선언되지 않은 변수 때문에 발생하는 오류 메시지는 `“ReferenceError : XYZ is not defined”` 와 유사하다. 이 오류 메시지에서 `not defined` 는 정의되지 않은 이라는 뜻을 가진 `undefined` 와 거의 동일한데 사람이 사용하는 언어인 자연어를 기준으로는 뜻이 유사하다. 그러나 JS에서 `not defined`와 `undefined` 는 전혀 다른 단어이다.

접근 가능한 렉시컬 스코프에 식별자에 해당하는 변수 선언이 있는 경우, `not defined`를 `not declared` 혹은 `undeclared`와 치환해서 생각해도 괜찮다. 반면 `undefined`는 변수는 발견되었는데(선언은 되어 있는데) 해당 시점에 값이 없는 경우를 의미한다.

JS에서 `typeof` 연산자는 선언되지 않은 변수나 값이 없는 변수를 넘겼을 때 똑같이 `undefined` 를 반환하기 때문에 혼란을 가증시킨다

```jsx
var studentName;
typeof studentName; // "undefined"

typeof doesntExist; // "undefined"
```

두 변수 참조는 분명 다른 상태임에도 불구하고 혼란을 불러 일으킨다.

<br>

### 전역 변수의 갑작스러운 등장

```jsx
function getStudentName() {
  // 변수가 선언되지 않았는데 할당을 했다.
  nextStudent = "서하";
}

getStudentName();

console.log(nextStudent);
// 뜬금없이 전역변수가 생기면서 "서하" 가 출력된다.
```

버그로 이어질 확률이 아주 높은 이런 종류의 사고는 엄격 모드가 필요한 아주 좋은 예이다. 선언된 적이 없는 변수에 값을 할당하는 건 오류가 맞으므로 당연히 `ReferenceError` 를 발생시켜야 한다.

우발적으로 등장하는 전역변수에 절대 의존하지 말아야하고, 항상 엄격 모드에서 작업하고 변수는 반드시 선언해서 사용하자. 이렇게 하면 선언되지 않은 변수에 값을 할당하려는 실수를 할 때 `ReferenceError` 가 나타나기 때문에, 오류의 원인을 정확히 파악 가능하다.

<br>

### 2.3.2 스코프 건물

1층부터 5층까지 있는 건물을 생각해보자.

건물은 중첩 스코프 모음이고, 1층은 현재 실행 중인 스코프를 나타낸다. 꼭대기 층은 전역스코프를 나타낸다.

타깃 혹은 소스 역할을 하는 변수 참조를 찾을 때는 지금 있는 층을 먼저 둘러본다. 현재 층에서 원하는 변수 참조를 찾지 못하면 엘리베이터를 타고 다음 층(바깥 스코프) 으로 가서 변수 참조를 찾는다. 게속해서 원하는 변수 참조를 찾다가 꼭대기층(전역 스코프)에 도달하면 원하는 변수 참조를 찾든 찾지 못했든 탐색이 중지된다.
